<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (iterators)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/iterators.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:48 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Iteradores en Python</title><link>http://deibit.com/posts/2011/04/05/iteradores-en-python/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Un iterador es un objeto sobre el que se puede…iterar. Aunque parece una obviedad es así. No puedes iterar sobre un número o tipo entero, ya que carece de la capacidad de iterar. Pero por ejemplo una lista si tiene esa capacidad:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; for n in [1,2,3]:&lt;br&gt;
…     print n&lt;br&gt;
…&lt;br&gt;
1&lt;br&gt;
2&lt;br&gt;
3&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;¿Que hace que un objeto pueda iterar? Lo hace gracias a un “protocolo”. Cuando se itera, en este caso en el bucle ‘for’, se llama a un método denominado ‘__iter__’, este método que pertenece al objeto lista (y a cualquier otro que lo implemente) va a devolver un objeto “iterator” y sobre el es sobre el que vamos a iterar:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; dir([])&lt;br&gt;
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; [1,2,3].__iter__()&lt;br&gt;
&amp;lt;listiterator object at 0xb74b69cc&amp;gt;&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a = [1,2,3].__iter__()&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; type(a)&lt;br&gt;
&amp;lt;type ‘listiterator’&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos como el objeto lista tiene el método ‘__iter__’ y que al ser llamado devuelve un objeto iterador. Este objeto lo asignamos a ‘a’.&lt;/p&gt;
&lt;p&gt;Ahora vemos que el objeto iterador implementa un método llamado ‘next’. Este método proporciona un objeto de la lista cada vez que es llamado o mejor dicho, cada vez que se produce una “iteración”. Al no haber más números en la lista, ‘next’, hace saltar la excepción “StopIteration”. La instrucción ‘for’ no propaga la excepción, simplemente la usa para salir de la iteración o bucle.&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; dir(a)&lt;br&gt;
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__length_hint__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'next']&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
1&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
2&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
3&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
Traceback (most recent call last):&lt;br&gt;
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;&lt;br&gt;
StopIteration&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;¿Podríamos construir nosotros nuestro propio iterador?&lt;/p&gt;
&lt;p&gt;Como no:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
class MyIter(object):&lt;br&gt;
    def __init__(self, n):&lt;br&gt;
        self.lista = range(1, n+1)&lt;br&gt;
        self.index = -1&lt;br&gt;
        self.limit = n&lt;br&gt;
    def __iter__(self):&lt;br&gt;
        return self&lt;br&gt;
    def next(self):&lt;br&gt;
        self.index += 1&lt;br&gt;
        if self.index == self.limit:&lt;br&gt;
            raise StopIteration&lt;br&gt;
        else:&lt;br&gt;
            return self.lista[self.index]&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Implementamos ‘__iter__’ que va a devolver al mismo objeto que implementa ‘next’ un metodo que será llamado hasta que devuelva todos los valores que contiene. En ese momento hace saltar la excepción ‘StopIteration’ para que el consumidor sepa que ya no hay más valores disponibles.&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; m = myiter.MyIter(8)&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; for n in m: print n&lt;br&gt;
…&lt;br&gt;
1&lt;br&gt;
2&lt;br&gt;
3&lt;br&gt;
4&lt;br&gt;
5&lt;br&gt;
6&lt;br&gt;
7&lt;br&gt;
8&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Relacionado con esto se puede ver el módulo ‘itertools’ y el tema de generadores.&lt;/p&gt;
</description><category>iterators</category><category>Python</category><guid>http://deibit.com/posts/2011/04/05/iteradores-en-python/</guid><pubDate>Tue, 05 Apr 2011 18:03:36 GMT</pubDate></item></channel></rss>