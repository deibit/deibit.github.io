<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (objective c)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/objective-c.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:49 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Designated Initializers in Objective C</title><link>http://deibit.com/posts/2012/06/30/designated-initializers-in-objective-c/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Object construction in Objective C is a two phase procedure. First the object has to be allocated in memory, hence the ‘alloc’ message we always see when a object is invoked this way (and not for example via a ‘get…’, which would be a Factory):&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
MyObject* o = [[MyObject alloc] init];&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Second phase involves object initialization which is quite similar to what would be a constructor in C++. When we implement method ‘init’ (which is just a convention) we have to take care on superclass designated initializer . But, what is a designated initializer at all?&lt;/p&gt;
&lt;p&gt;Designated initializer is the method that best set up our object between all initializer methods. An example:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
- (id) init:&lt;br&gt;
- (id) initWithColor:(NSColor*)color;&lt;br&gt;
- (id) initWithColor:(NSColor*)color andSize:(NSInteger)size;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;What method do you think is the most complete?&lt;/p&gt;
&lt;p&gt;Our third method includes two parameter while the other only one or none.&lt;/p&gt;
&lt;p&gt;Now, we got a pattern that you are going to see every time you implement your own objects:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
- (id) init&lt;br&gt;
{&lt;br&gt;
if (self = [super init]) {&lt;br&gt;
}&lt;br&gt;
return self;&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;This is the most basic method. It neither do variable initialization nor call other initializers. It just call its superclass initializer, check its got a valid pointer back (thus not nil) and return self.&lt;/p&gt;
&lt;p&gt;But if we got any other initializer methods we must call our most complete initializer. This is the designated initializer. So instead of our light ‘init’ tiny method we would have to call initWithColor:andSize:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
- (id) init&lt;br&gt;
{&lt;br&gt;
NSColor* color = [NSColor greenColor];&lt;br&gt;
NSInteger size = 30;&lt;br&gt;
return [self initWithColor:color andSize:size];&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;and in our initWithColor:andSize:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
- (id) initWithColor:(NSColor*)color andSize:(NSInteger)size&lt;br&gt;
{&lt;br&gt;
if (self = [super init]) {&lt;br&gt;
_color = [color retain];&lt;br&gt;
_size = size;&lt;br&gt;
}&lt;br&gt;
return self&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
</description><category>initializer</category><category>objective c</category><guid>http://deibit.com/posts/2012/06/30/designated-initializers-in-objective-c/</guid><pubDate>Sat, 30 Jun 2012 04:59:35 GMT</pubDate></item><item><title>Protocols in Objective C</title><link>http://deibit.com/posts/2012/06/29/protocols-in-objective-c-12/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Just a reference note on how to implement a “protocol” in Objective C.&lt;/p&gt;
&lt;p&gt;First. We define our protocol in a file named “Protocol.h”:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
@protocol Protocol&lt;/p&gt;
&lt;p&gt;@required&lt;br&gt;
- (void)requiredMethod:(NSString*)param;&lt;/p&gt;
&lt;p&gt;@optional&lt;br&gt;
- (void)optionalMethod;&lt;/p&gt;
&lt;p&gt;@end&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;We can declare a method as optional or required. If the method is required you must implement that method in your class.&lt;/p&gt;
&lt;p&gt;Next, we decided to use the protocol in our class, first the header “UseProtocol.h” then the implementation “UseProtocol.m”:&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;br&gt;
#import "Protocol.h"&lt;/p&gt;
&lt;p&gt;@interface UseProtocol : NSObject &amp;lt;Protocol&amp;gt;&lt;br&gt;
@end&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;/p&gt;
&lt;p&gt;#import "UseProtocol.h"&lt;/p&gt;
&lt;p&gt;@implementation UseProtocol&lt;/p&gt;
&lt;p&gt;- (void)requiredMethod:(NSString*)param {&lt;br&gt;
 NSLog(@"%@", param);&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;@end&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;and next we glue it up together in a main.m&lt;/p&gt;
&lt;p&gt;[sourcecode language="objc"]&lt;br&gt;
#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;br&gt;
#import "UseProtocol.h"&lt;/p&gt;
&lt;p&gt;int main(int argc, const char* argv[]) {&lt;br&gt;
 NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];&lt;br&gt;
 UseProtocol* p = [[UseProtocol alloc] init];&lt;br&gt;
 [p requiredMethod:@"test"];&lt;br&gt;
 [p release];&lt;br&gt;
 [pool drain];&lt;br&gt;
 return 0;&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;We could use XCode but is too heavy for our little task…&lt;/p&gt;
&lt;p&gt;If you used an editor, you can compiled it through command line:&lt;/p&gt;
&lt;p&gt;[sourcecode]clang -framework Foundation UseProtocol.m main.m -o main[/sourcecode]&lt;/p&gt;
</description><category>cocoa</category><category>command line</category><category>mac osx</category><category>objective c</category><category>protocols</category><guid>http://deibit.com/posts/2012/06/29/protocols-in-objective-c-12/</guid><pubDate>Fri, 29 Jun 2012 10:28:17 GMT</pubDate></item></channel></rss>