<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (Python)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/python.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><lastBuildDate>Sun, 17 Jul 2016 10:19:58 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Cansina Web Content Discovery Tool</title><link>http://deibit.com/posts/2013/04/18/cansina-web-content-discover-tool/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;I forgot to mention here in my blog a web pentest tool I’m making: &lt;a href="https://github.com/deibit/cansina"&gt;Cansina&lt;/a&gt;. Is just a little tool to discover by dictionary hidden content in a website. Useful (I hope) while doing web security assessment.   It is code in Python and accepts list of entries in plain text files that will use to tireless ask the website. It has a couple of interesting options and more is to come. If you are a pentester take a look at it. I hope it would be useful for you.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://daganu.files.wordpress.com/2013/04/cansina-showcase.png"&gt;&lt;img class="size-full wp-image" id="i-618" alt="Image" src="http://daganu.files.wordpress.com/2013/04/cansina-showcase.png?w=650"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/deibit/cansina&lt;/p&gt;
</description><category>pentesting</category><category>Python</category><category>security</category><category>tool</category><category>web</category><guid>http://deibit.com/posts/2013/04/18/cansina-web-content-discover-tool/</guid><pubDate>Thu, 18 Apr 2013 15:26:00 GMT</pubDate></item><item><title>Calling Python from C++</title><link>http://deibit.com/posts/2013/02/17/calling-python-from-c/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Just a little snippet of code to show how to call python (an entire Python interpreter) from inside a C++ program:&lt;/p&gt;
&lt;p&gt;[code lang="cpp"]&lt;br&gt;
#include &amp;lt;Python.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main(int argc, char const *argv[])&lt;br&gt;
{&lt;br&gt;
Py_SetProgramName(const_cast&amp;lt;char*&amp;gt;(argv[0]));&lt;br&gt;
Py_Initialize();&lt;br&gt;
PyRun_SimpleString("from time import time,ctime\n" "print ‘Today is’,ctime(time())\n");&lt;br&gt;
Py_Finalize();&lt;br&gt;
return 0;&lt;br&gt;
}&lt;br&gt;
[/code]&lt;/p&gt;
&lt;p&gt;You will need the path to the Python headers and library “libpython2.7″ (2.7 for the Python version).&lt;/p&gt;
&lt;p&gt;In OSX I asked clang++ this way:&lt;/p&gt;
&lt;p&gt;clang++ -I./python2.7 -L. -lpython2.7 pyfromcpp.cpp -o pyfromcpp
&lt;/p&gt;</description><category>c++</category><category>call</category><category>calling</category><category>clang</category><category>Python</category><guid>http://deibit.com/posts/2013/02/17/calling-python-from-c/</guid><pubDate>Sun, 17 Feb 2013 00:50:36 GMT</pubDate></item><item><title>Iteradores en Python</title><link>http://deibit.com/posts/2011/04/05/iteradores-en-python/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Un iterador es un objeto sobre el que se puede…iterar. Aunque parece una obviedad es así. No puedes iterar sobre un número o tipo entero, ya que carece de la capacidad de iterar. Pero por ejemplo una lista si tiene esa capacidad:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; for n in [1,2,3]:&lt;br&gt;
…     print n&lt;br&gt;
…&lt;br&gt;
1&lt;br&gt;
2&lt;br&gt;
3&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;¿Que hace que un objeto pueda iterar? Lo hace gracias a un “protocolo”. Cuando se itera, en este caso en el bucle ‘for’, se llama a un método denominado ‘__iter__’, este método que pertenece al objeto lista (y a cualquier otro que lo implemente) va a devolver un objeto “iterator” y sobre el es sobre el que vamos a iterar:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; dir([])&lt;br&gt;
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; [1,2,3].__iter__()&lt;br&gt;
&amp;lt;listiterator object at 0xb74b69cc&amp;gt;&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a = [1,2,3].__iter__()&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; type(a)&lt;br&gt;
&amp;lt;type ‘listiterator’&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos como el objeto lista tiene el método ‘__iter__’ y que al ser llamado devuelve un objeto iterador. Este objeto lo asignamos a ‘a’.&lt;/p&gt;
&lt;p&gt;Ahora vemos que el objeto iterador implementa un método llamado ‘next’. Este método proporciona un objeto de la lista cada vez que es llamado o mejor dicho, cada vez que se produce una “iteración”. Al no haber más números en la lista, ‘next’, hace saltar la excepción “StopIteration”. La instrucción ‘for’ no propaga la excepción, simplemente la usa para salir de la iteración o bucle.&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; dir(a)&lt;br&gt;
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__length_hint__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'next']&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
1&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
2&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
3&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; a.next()&lt;br&gt;
Traceback (most recent call last):&lt;br&gt;
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;&lt;br&gt;
StopIteration&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;¿Podríamos construir nosotros nuestro propio iterador?&lt;/p&gt;
&lt;p&gt;Como no:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
class MyIter(object):&lt;br&gt;
    def __init__(self, n):&lt;br&gt;
        self.lista = range(1, n+1)&lt;br&gt;
        self.index = -1&lt;br&gt;
        self.limit = n&lt;br&gt;
    def __iter__(self):&lt;br&gt;
        return self&lt;br&gt;
    def next(self):&lt;br&gt;
        self.index += 1&lt;br&gt;
        if self.index == self.limit:&lt;br&gt;
            raise StopIteration&lt;br&gt;
        else:&lt;br&gt;
            return self.lista[self.index]&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Implementamos ‘__iter__’ que va a devolver al mismo objeto que implementa ‘next’ un metodo que será llamado hasta que devuelva todos los valores que contiene. En ese momento hace saltar la excepción ‘StopIteration’ para que el consumidor sepa que ya no hay más valores disponibles.&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; m = myiter.MyIter(8)&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt; for n in m: print n&lt;br&gt;
…&lt;br&gt;
1&lt;br&gt;
2&lt;br&gt;
3&lt;br&gt;
4&lt;br&gt;
5&lt;br&gt;
6&lt;br&gt;
7&lt;br&gt;
8&lt;br&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Relacionado con esto se puede ver el módulo ‘itertools’ y el tema de generadores.&lt;/p&gt;
</description><category>iterators</category><category>Python</category><guid>http://deibit.com/posts/2011/04/05/iteradores-en-python/</guid><pubDate>Tue, 05 Apr 2011 18:03:36 GMT</pubDate></item><item><title>La sentencia 'with' de Python</title><link>http://deibit.com/posts/2011/04/04/la-sentencia-with-de-python/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;‘with’ se introdujo en Python 2.5. En esa versión no estaba disponible directamente (eso fue a partir de la 2.6) y había que importarla con ‘with_statement’.&lt;/p&gt;
&lt;p&gt;‘with’ es una sentencia relacionada con la gestión de recursos y su tratamiento cuando estos provocan una excepción o salen de su entorno.&lt;/p&gt;
&lt;p&gt;Un ejemplo simple. Queremos abrir un fichero asignándolo a una variable, algo común en el quehacer diario.&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
try:&lt;br&gt;
    f = open("test_with.txt", ‘w’)&lt;br&gt;
    f.write("prueba")&lt;br&gt;
except:&lt;br&gt;
    print "error al abrir fichero"&lt;br&gt;
finally:&lt;br&gt;
    if f:&lt;br&gt;
        f.close()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;El código es bastante autoexplicativo. f es el nombre al que asignamos un objeto archivo. Esta operación, la apertura de un archivo y escritura en el, puede ocasionar varios errores de naturaleza múltiple (no esta el archivo, no tenemos permisos…). Por ello capturamos la excepción y gestionamos. Si todo sale bien pasaremos a la clausula ‘finally’ y allí gestionaremos la liberación del recurso, en este caso simplemente cerrar el archivo.&lt;/p&gt;
&lt;p&gt;En este caso, somos nosotros los que estamos gestionando el recurso al cerrarlo ocurra o no una excepción. Mientras que somos responsables de responder ante las excepciones que este objeto nos quiera comunicar, gestionar el cierre del recurso es algo que el mismo recurso podría gestionar mejor que nosotros.&lt;/p&gt;
&lt;p&gt;¿No estaría mejor abrir el archivo, operar sobre el y listo?&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
try:&lt;br&gt;
    with open("test22.txt",’r') as f:&lt;br&gt;
        f.write("prueba")&lt;br&gt;
except:&lt;br&gt;
    print "no esta el fichero"&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;En este fragmento ocurre eso precisamente. Gracias a ‘with’. Si observamos notaremos la ausencia del cierre del recurso, la comprobación de que sí está asignado a la variable ‘f’ y por supuesto, la clausula ‘finally’, ya que es el propio recurso quien se gestiona su propio cierre.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Como ocurre esto?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cualquier tipo puede ser gestionado por ‘with’ a través de un “Manejador de contexto” (Context manager). Un manejador de contexto son dos funciones que van a ser llamadas por Python durante la ejecución. Los nombres son ‘__enter__’ y ‘__exit__’. Cuando se opera sobre el objeto se llama a ‘__enter__’ y cuando se sale, por cualquier motivo, se llama a ‘__exit__’.&lt;/p&gt;
&lt;p&gt;Un ejemplo:&lt;/p&gt;
&lt;p&gt;[sourcecode language="python"]&lt;br&gt;
class With_Test(object):&lt;br&gt;
    def __init__(self, n):&lt;br&gt;
        print "en init…"&lt;br&gt;
        self.n = n&lt;br&gt;
    def __enter__(self):&lt;br&gt;
        print "entrando…"&lt;br&gt;
        return self&lt;br&gt;
    def __exit__(self, exc_type, exec_value, traceback):&lt;br&gt;
        print "saliendo…"&lt;br&gt;
    def metodo(self):&lt;br&gt;
        print "n vale: %s" % self.n&lt;/p&gt;
&lt;p&gt;with With_Test(8) as wt:&lt;br&gt;
    wt.metodo()&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Esto imprimirá por pantalla:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
bellucci:python david$ python test_with.py&lt;br&gt;
en init…&lt;br&gt;
entrando…&lt;br&gt;
n vale: 8&lt;br&gt;
saliendo…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si construimos nuestros objetos con este método abstraemos a los usuarios de nuestras clases de la gestión de cierre del recurso. La sintaxis es más clara y elegante. &lt;/p&gt;
</description><category>Programming</category><category>Python</category><guid>http://deibit.com/posts/2011/04/04/la-sentencia-with-de-python/</guid><pubDate>Mon, 04 Apr 2011 20:04:17 GMT</pubDate></item><item><title>vim: Filtrar código Python en vim</title><link>http://deibit.com/posts/2010/11/09/vim-filtrar-codigo-python-en-vim/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;La idea es aprovechar el “filtrado a través de un comando” el ya conocido:&lt;/p&gt;
&lt;p&gt;r!(comando) por ejemplo con ls: :r!ls&lt;/p&gt;
&lt;p&gt;y con ello insertaríamos la salida en nuestro texto.&lt;/p&gt;
&lt;p&gt;¿Qué tal usar Python, interpretar la cadena como código y pegar la salida?&lt;/p&gt;
&lt;p&gt;Ponemos esto en nuestro vimrc:&lt;/p&gt;
&lt;p&gt;nmap gp :.!python&lt;br&gt;vmap gp :!python&lt;/p&gt;
&lt;p&gt;Donde gp, obviamente podemos poner la combinación que más nos guste.&lt;/p&gt;
&lt;p&gt;Visto en &lt;a href="http://www.reddit.com/r/vim/comments/e341j/time_for_a_vim_tricks_thread_please_search_before/c14x2oh"&gt;Reddit&lt;/a&gt;&lt;/p&gt;
</description><category>cookbook</category><category>Programming</category><category>Python</category><category>vim</category><guid>http://deibit.com/posts/2010/11/09/vim-filtrar-codigo-python-en-vim/</guid><pubDate>Tue, 09 Nov 2010 00:05:00 GMT</pubDate></item><item><title>Python: Incoherencias en los nombres</title><link>http://deibit.com/posts/2010/07/09/python-incoherencias-en-los-nombres/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Una de las cosas que más valoro de Java es la consistencia en el empleo de estilo con respecto a los nombres de métodos, clases, etc. En Python, a pesar del &lt;a href="http://www.python.org/dev/peps/pep-0008/"&gt;PEP8 &lt;/a&gt;que indica o recomienda ciertos usos, nos encontramos con una variedad de estilos en los nombres de funciones y métodos de clases:&lt;/p&gt;
&lt;p&gt;Del módulo ‘&lt;i&gt;threading&lt;/i&gt;‘:&lt;/p&gt;
&lt;p&gt;Como se inspiró en la API de Java, nos encontramos con el camelCase habitual:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;threading.currentThread()&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Sin embargo, han sido renombrados para que sean conformes al PEP8:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;threading.current_thread()&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;y además: &lt;i&gt;“However, no schedule has been set for the deprecation of the camelCase  names and they remain fully supported in both Python 2.x and 3.x.”&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Lo cual se traduce que incluso en la versión 3 de Python nos vamos a topar con distintos estilos en los fuentes que encontremos.&lt;/p&gt;
&lt;p&gt;Más. Los nombres de función han de ser en minúsculas y separados por guión bajo:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;esto_es_una_funcion()&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Pero, nuevamente en el módulo ‘&lt;i&gt;threading&lt;/i&gt;‘:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;threading.Condition()&lt;br&gt;A factory function that returns a new….&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;No acaba aquí la cosa, en los nombres de módulos:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Modules should have short, all-lowercase names.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Y como no, nos encontramos en los módulos estándar:&lt;/p&gt;
&lt;p&gt;&lt;i&gt;BaseHTTPServer&lt;br&gt;ConfigParser&lt;br&gt;cPickle&lt;br&gt;cProfile &lt;/i&gt;&lt;br&gt;…&lt;/p&gt;
&lt;p&gt;Aunque muchos de ellos se están pasando al estilo del PEP8.&lt;/p&gt;
&lt;p&gt;Esto (y el cansino ‘self’) es una de las cosillas que molestan de Python. Seguir un estilo es utilísimo, con sólo un vistazo, sabemos que tenemos delante, máxime en un lenguaje dinámico donde no tenemos el apoyo de la sintaxis explicita (int, float…) al declarar un objeto.&lt;/p&gt;
</description><category>Programming</category><category>Python</category><guid>http://deibit.com/posts/2010/07/09/python-incoherencias-en-los-nombres/</guid><pubDate>Thu, 08 Jul 2010 22:44:00 GMT</pubDate></item></channel></rss>