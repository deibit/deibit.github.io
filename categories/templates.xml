<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>deibit (templates)</title><link>http://deibit.com/</link><description></description><atom:link type="application/rss+xml" rel="self" href="http://deibit.com/categories/templates.xml"></atom:link><language>es</language><lastBuildDate>Sun, 17 Jul 2016 09:42:34 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Inicialización de variables en plantillas</title><link>http://deibit.com/posts/2010/12/06/inicializacion-de-variables-en-plantillas/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Cuando tratamos con tipos básicos nos encontramos con el problema de no saber a que valor debemos inicializarlo.&lt;/p&gt;
&lt;p&gt;Si el tipo es un entero podría ser ’0′ pero si es float el equivalente es ’0.0′&lt;/p&gt;
&lt;p&gt;En este caso no sabemos como inicializarlo:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;&lt;br&gt;
void funcion()&lt;br&gt;
{&lt;br&gt;
    T x;&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Para inicializar a cero cualquier valor disponemos de un “inicializador”: &lt;em&gt;T x = T();&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;&lt;br&gt;
void funcion()&lt;br&gt;
{&lt;br&gt;
    T x = T();&lt;br&gt;
}&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;En el caso de una función miembro, podemos hacerlo en la lista de inicialización de un constructor.&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;&lt;br&gt;
class Test&lt;br&gt;
{&lt;br&gt;
   T var_miembro;&lt;br&gt;
   Test() : var_miembro() {}&lt;br&gt;
};&lt;br&gt;
[/sourcecode]&lt;/p&gt;
</description><category>c++</category><category>Programming</category><category>templates</category><guid>http://deibit.com/posts/2010/12/06/inicializacion-de-variables-en-plantillas/</guid><pubDate>Mon, 06 Dec 2010 09:05:27 GMT</pubDate></item><item><title>Miembros de clase con plantillas</title><link>http://deibit.com/posts/2010/12/06/miembros-de-clase-con-plantillas/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Aunque nuestra clase sea o no una clase plantilla sus miembros pueden ser plantillas a su vez o independientemente.&lt;/p&gt;
&lt;p&gt;Esto permite que una función miembro acepte un parámetro de tipo arbitrario.&lt;/p&gt;
&lt;p&gt;Por ejemplo al sobrecargar un constructor de copia.&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
vector&amp;lt;int&amp;gt; vInt1;&lt;br&gt;
vector&amp;lt;int&amp;gt; vInt2;&lt;br&gt;
vector&amp;lt;float&amp;gt; vFloat1;&lt;br&gt;
…&lt;br&gt;
vInt1 = vInt2; // correcto&lt;br&gt;
vInt1 = vFloat1; // error&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;En la cabecera de la clase (&lt;em&gt;clase.h&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
…&lt;br&gt;
template &amp;lt;typename T2&amp;gt;&lt;br&gt;
    vector&amp;lt;T&amp;gt;&amp;amp; operator= (vector&amp;lt;T2&amp;gt; const&amp;amp;);&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;En la implementación:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;  // si procede en la clase&lt;br&gt;
 template &amp;lt;typename T2&amp;gt;&lt;br&gt;
vector&amp;lt;T&amp;gt;&amp;amp; vector&amp;lt;T&amp;gt;::operator= (vector&amp;lt;T2&amp;gt; const&amp;amp; op2)&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
</description><category>c++</category><category>Programming</category><category>templates</category><guid>http://deibit.com/posts/2010/12/06/miembros-de-clase-con-plantillas/</guid><pubDate>Mon, 06 Dec 2010 08:28:45 GMT</pubDate></item><item><title>'typename' para evitar ambigüedades</title><link>http://deibit.com/posts/2010/12/06/typename-para-evitar-ambiguedades/</link><dc:creator>David García</dc:creator><description>&lt;p&gt;Vamos a suponer que tenemos una clase donde dentro de ella hemos definido un tipo:&lt;br&gt;
[sourcecode language="cpp"]&lt;br&gt;
…&lt;br&gt;
typedef std::vector&amp;lt;int&amp;gt; Container;&lt;br&gt;
…&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Si hacemos referencia a este tipo para crear por ejemplo un nuevo objeto. Intuitivamente nos sale esto:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;&lt;br&gt;
class CTest&lt;br&gt;
{&lt;br&gt;
   T::Container * ptr;&lt;br&gt;
};&lt;br&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Pero curiosamente lo que interpreta el compilador es que estamos multiplicando ‘ptr’ por un miembro clase de CTest.&lt;/p&gt;
&lt;p&gt;Para evitarlo se hace uso de ‘typename’.&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br&gt;
template &amp;lt;typename T&amp;gt;&lt;br&gt;
class CTest&lt;br&gt;
{&lt;br&gt;
   typename T::Container * ptr;&lt;br&gt;
};&lt;br&gt;
[/sourcecode]&lt;/p&gt;
</description><category>c++</category><category>Programming</category><category>templates</category><guid>http://deibit.com/posts/2010/12/06/typename-para-evitar-ambiguedades/</guid><pubDate>Mon, 06 Dec 2010 07:28:09 GMT</pubDate></item></channel></rss>